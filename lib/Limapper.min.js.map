{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///Limapper.min.js","webpack:///webpack/bootstrap 3a511d801cf3baa101e0","webpack:///external \"L\"","webpack:///./src/index.js","webpack:///./~/leaflet-editable/src/Leaflet.Editable.js","webpack:///./~/leaflet.path.drag/src/Path.Drag.js"],"names":["root","factory","exports","module","require","define","amd","this","__WEBPACK_EXTERNAL_MODULE_0__","modules","__webpack_require__","moduleId","installedModules","i","l","call","m","c","value","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","_interopRequireDefault","obj","default","_classCallCheck","instance","Constructor","TypeError","_createClass","defineProperties","target","props","length","descriptor","writable","key","protoProps","staticProps","_leaflet","_leaflet2","Limapper","_name","_latestItem","_selectedItem","_identity","item","self","v","_map","map","po","latLngToLayerPoint","LatLng","editor","Editable","RectangleEditor","_bounds","mapdata","rect","nw","getNorthWest","se","getSouthEast","x1","x","x2","y1","y","y2","opts","defs","minZoom","maxZoom","center","zoom","editable","crs","CRS","Simple","southWest","northEast","bounds","layerPopup","k","elid","unproject","imageHeight","imageWidth","LatLngBounds","imageOverlay","imageUrl","addTo","setMaxBounds","EditControl","Control","extend","options","position","callback","kind","html","onAdd","container","DomUtil","create","link","href","title","innerHTML","DomEvent","on","stop","window","LAYER","editTools","NewRectangleControl","startRectangle","addControl","e","layer","Path","toggleEdit","popup","setLatLng","latlng","setContent","openOn","closePopup","containerPointToLatLng","mapData","rectangle","p2ll","enableEdit","items","rst","forEach","it","addItem","push","remove","eachLayer","getData","getMapData","__WEBPACK_AMD_DEFINE_FACTORY__","__WEBPACK_AMD_DEFINE_ARRAY__","__WEBPACK_AMD_DEFINE_RESULT__","undefined","apply","L","Evented","statics","FORWARD","BACKWARD","zIndex","polygonClass","Polygon","polylineClass","Polyline","markerClass","Marker","rectangleClass","Rectangle","circleClass","Circle","drawingCSSClass","drawingCursor","editLayer","featuresLayer","polylineEditorClass","polygonEditorClass","markerEditorClass","rectangleEditorClass","circleEditorClass","lineGuideOptions","skipMiddleMarkers","initialize","setOptions","_lastZIndex","createEditLayer","createFeaturesLayer","forwardLineGuide","createLineGuide","backwardLineGuide","fireAndForward","type","fire","dashArray","weight","interactive","polyline","createVertexIcon","Browser","touch","TouchVertexIcon","VertexIcon","LayerGroup","moveForwardLineGuide","_latlngs","redraw","moveBackwardLineGuide","anchorForwardLineGuide","anchorBackwardLineGuide","attachForwardLineGuide","addLayer","attachBackwardLineGuide","detachForwardLineGuide","setLatLngs","removeLayer","detachBackwardLineGuide","blockEvents","_oldTargets","_targets","unblockEvents","registerForDrawing","_drawingEditor","unregisterForDrawing","reset","onDrawingMouseMove","onMousedown","onMouseup","addClass","_container","defaultMapCursor","style","cursor","removeClass","off","_drawing","cancelDrawing","_mouseDown","onDrawingMouseDown","mouseDown","onDrawingMouseUp","origin","point","originalEvent","clientX","clientY","distance","distanceTo","Math","abs","devicePixelRatio","onDrawingClick","drawing","stopDrawing","commitDrawing","connectCreatedToMap","startPolyline","line","createPolyline","newShape","startPolygon","polygon","createPolygon","startMarker","getCenter","clone","marker","createMarker","startDrawing","corner","latLng","createRectangle","startCircle","circle","createCircle","startHole","newHole","createLayer","klass","latlngs","Util","editOptions","makeCancellable","cancel","_cancelled","Map","mergeOptions","editToolsClass","addInitHook","whenReady","DivIcon","iconSize","Point","VertexMarker","draggable","className","icon","tools","__vertex","setZIndexOffset","onDrag","onDragStart","onDragEnd","onClick","onContextMenu","onMouseDown","addMiddleMarkers","onRemove","middleMarker","delete","vertex","onVertexMarkerDrag","iconPos","getPosition","_icon","layerPointToLatLng","update","_latlng","refresh","updateLatLng","next","getNext","onVertexMarkerDragStart","onVertexMarkerDragEnd","onVertexMarkerClick","onVertexMarkerContextMenu","onVertexMarkerMouseDown","splice","getIndex","onVertexDeleted","deleteShape","resetMiddleMarker","indexOf","getLastIndex","getPrevious","index","previousIndex","CLOSED","previous","nextIndex","addMiddleMarker","hasMiddleMarkers","split","splitShape","continue","continueBackward","continueForward","vertexMarkerClass","MiddleMarker","opacity","left","right","computeLatLng","_opacity","setVisibility","leftPoint","latLngToContainerPoint","rightPoint","size","hide","show","setOpacity","onMiddleMarkerMouseDown","addVertexMarker","parent","parentNode","removeChild","appendChild","_initIcon","_initInteraction","Draggable","_dragging","dragging","_draggable","_onDown","middleMarkerClass","BaseEditor","Handler","feature","addHooks","isConnected","onFeatureAdd","once","onEnable","_getEvents","removeHooks","disable","clearLayers","onDisable","enable","onEditing","onStartDrawing","onEndDrawing","onCancelDrawing","onCommitDrawing","endDrawing","connect","processDrawingClick","hasLayer","onMove","dragstart","drag","dragend","MarkerEditor","PathEditor","MIN_VERTEX","initVertexMarkers","enabled","getLatLngs","_flat","addVertexMarkers","refreshVertexMarkers","getDefaultLatLngs","commit","ctrlKey","onVertexMarkerCtrlClick","altKey","onVertexMarkerAltClick","shiftKey","onVertexMarkerShiftClick","metaKey","onVertexMarkerMetaKeyClick","_drawnLatLngs","onVertexRawMarkerClick","vertexCanBeDeleted","extendBounds","setDrawnLatLngs","startDrawingForward","addLatLng","unshift","newPointForward","newPointBackward","console","error","removeLatLng","pop","shape","addNewEmptyShape","_deleteShape","ensureNotFlat","inplaceDelete","Number","MAX_VALUE","spliceDelete","deleteShapeAt","shapeAt","appendShape","insertShape","prependShape","ensureMulti","formatShape","_enabled","PolylineEditor","startDrawingBackward","shapeIndex","first","slice","second","lat","lng","alt","PolygonEditor","addNewEmptyHole","holes","parentShape","oppositeIndex","opposite","updateBounds","updateLatLngs","_simulated","_onUp","newLatlngs","_boundsToLatLngs","CircleEditor","_resizeLatLng","computeResizeLatLng","delta","_radius","_mRadius","cos","PI","project","updateResizeLatLng","resize","radius","setRadius","EditableMixin","createEditor","Error","editorClass","getEditorClass","editEnabled","disableEdit","_onEditableAdd","PolylineMixin","isInLatLngs","len","part","w","_clickTolerance","_projectLatlngs","_pxBounds","contains","LineUtil","pointToSegmentDistance","PolygonMixin","l1","l2","j","len2","inside","idx","MarkerMixin","RectangleMixin","CircleMixin","keepEditable","include","PathDraggable","path","_path","_canvas","getRenderer","Canvas","element","_updatePosition","_lastEvent","touches","_startPoint","_containsPoint","mouseEventToLayerPoint","PathDrag","getEvents","_onDragStart","_onDrag","_onDragEnd","_element","moved","_moved","event","newPoint","_offset","subtract","eachLatLng","offset","resetBounds","_subtract","getPixelOrigin","oldPoint","_add","newLatLng","context","loop","isArray","getLatLng"],"mappings":"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","file":"Limapper.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"L\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"Limapper\", [\"L\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Limapper\"] = factory(require(\"L\"));\n\telse\n\t\troot[\"Limapper\"] = factory(root[\"L\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_0__) {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","/*!\n *  Limapper.js - v0.2.2\n *  build: Tue Jun 13 2017 16:39:45 GMT-0500 (CDT)\n *  Leaflet Image Mapper\n */\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"L\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"Limapper\", [\"L\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Limapper\"] = factory(require(\"L\"));\n\telse\n\t\troot[\"Limapper\"] = factory(root[\"L\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_0__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 4);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports) {\n\nmodule.exports = __WEBPACK_EXTERNAL_MODULE_0__;\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _leaflet = __webpack_require__(0);\n\nvar _leaflet2 = _interopRequireDefault(_leaflet);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n__webpack_require__(3);\n__webpack_require__(2);\n\n/**\n * Leaflet Image Mapper\n */\n\nvar Limapper = function () {\n  /**\n   * initialize object\n   * @return {object} Instance\n   */\n  function Limapper() {\n    _classCallCheck(this, Limapper);\n\n    this._name = 'Limapper';\n    this._latestItem = null;\n    this._selectedItem = null;\n    this._identity = 1;\n  }\n\n  /**\n   * get name\n   * @return {string} name\n   */\n\n\n  _createClass(Limapper, [{\n    key: 'getMapData',\n\n\n    /**\n     * get item mapped data\n     * @param  {object} item\n     * @return {object}      item or null if no data found\n     */\n    value: function getMapData(item) {\n      var self = this;\n      var v = item;\n\n      if (!self._map) {\n        return null;\n      }\n\n      var map = self._map;\n      var po = map.latLngToLayerPoint(new _leaflet2.default.LatLng(0, 0));\n\n      // handle rectangle\n      if (v.editor instanceof _leaflet2.default.Editable.RectangleEditor) {\n        if (v._bounds) {\n          if (!v.mapdata) {\n            v.mapdata = { rect: {} };\n          }\n          var nw = map.latLngToLayerPoint(v._bounds.getNorthWest());\n          var se = map.latLngToLayerPoint(v._bounds.getSouthEast());\n\n          v.mapdata.rect.x1 = nw.x - po.x;\n          v.mapdata.rect.x2 = se.x - po.x;\n          v.mapdata.rect.y1 = nw.y - po.y;\n          v.mapdata.rect.y2 = se.y - po.y;\n          return v;\n        }\n      }\n      return null;\n    }\n\n    /**\n     * initialize object\n     * @param  {object} opts options\n     * @return {object}      self\n     */\n\n  }, {\n    key: 'init',\n    value: function init(opts) {\n      var self = this;\n      var defs = {\n        minZoom: 1,\n        maxZoom: 5,\n        center: [0, 0],\n        zoom: 1,\n        editable: true,\n        crs: _leaflet2.default.CRS.Simple\n      };\n      var southWest = void 0,\n          northEast = void 0,\n          bounds = void 0,\n          map = void 0,\n          layerPopup = void 0;\n\n      // apply defaults\n      for (var k in defs) {\n        opts[k] = opts[k] || defs[k];\n      }\n      map = _leaflet2.default.map(opts.elid || 'map', opts);\n      southWest = map.unproject([0, opts.imageHeight]);\n      northEast = map.unproject([opts.imageWidth, 0]);\n      bounds = new _leaflet2.default.LatLngBounds(southWest, northEast);\n      _leaflet2.default.imageOverlay(opts.imageUrl, bounds).addTo(map);\n      map.setMaxBounds(bounds);\n      this._map = map;\n\n      // add new edit control with behavior\n      _leaflet2.default.EditControl = _leaflet2.default.Control.extend({\n        options: {\n          position: 'topleft',\n          callback: null,\n          kind: '',\n          html: ''\n        },\n        onAdd: function onAdd(map) {\n          var container = _leaflet2.default.DomUtil.create('div', 'leaflet-control leaflet-bar'),\n              link = _leaflet2.default.DomUtil.create('a', '', container);\n\n          link.href = '#';\n          link.title = 'Create a new ' + this.options.kind;\n          link.innerHTML = this.options.html;\n          _leaflet2.default.DomEvent.on(link, 'click', _leaflet2.default.DomEvent.stop).on(link, 'click', function () {\n            window.LAYER = this.options.callback.call(map.editTools);\n          }, this);\n\n          return container;\n        }\n      });\n\n      // now create the rectangle control\n      _leaflet2.default.NewRectangleControl = _leaflet2.default.EditControl.extend({\n        options: {\n          position: 'topleft',\n          callback: map.editTools.startRectangle,\n          kind: 'rect',\n          html: '⬛'\n        }\n      });\n\n      // add the control to map\n      map.addControl(new _leaflet2.default.NewRectangleControl());\n\n      // handle new item\n      map.on('layeradd', function (e) {\n        if (e.layer instanceof _leaflet2.default.Path) {\n          var item = e.layer;\n\n          self._latestItem = item;\n          item.mapdata = { name: 'Item #' + self._identity++ };\n          item.on('dblclick', _leaflet2.default.DomEvent.stop).on('dblclick', item.toggleEdit);\n          item.on('mouseover', function (e) {\n            if (map && item.mapdata) {\n              layerPopup = _leaflet2.default.popup().setLatLng(e.latlng).setContent(item.mapdata.name).openOn(map);\n            }\n          });\n\n          item.on('mouseout', function (e) {\n            if (layerPopup && map) {\n              map.closePopup(layerPopup);\n              layerPopup = null;\n            }\n          });\n        }\n      });\n\n      return self;\n    }\n\n    /**\n     * get items\n     * @return {Array} list of items\n     */\n\n  }, {\n    key: 'p2ll',\n    value: function p2ll(x, y) {\n      return this._map.containerPointToLatLng([x, y]);\n    }\n\n    /**\n     * add a single pixel coordinates item\n     * @param {object} mapData item map data\n     */\n\n  }, {\n    key: 'addItem',\n    value: function addItem(mapData) {\n      var self = this;\n      var rect = mapData.rect;\n\n      var layer = _leaflet2.default.rectangle([self.p2ll(rect.x1, rect.y1), self.p2ll(rect.x2, rect.y2)]).addTo(self._map);\n\n      layer.enableEdit();\n      return layer;\n    }\n  }, {\n    key: 'addItems',\n    value: function addItems(items) {\n      var self = this;\n      var rst = [];\n\n      items.forEach(function (i) {\n        var it = self.addItem(i);\n\n        rst.push(it);\n      });\n\n      return it;\n    }\n\n    /**\n     * remove item\n     * @param {object} item the map data item\n     */\n\n  }, {\n    key: 'removeItem',\n    value: function removeItem(item) {\n      if (item && item.remove) {\n        item.remove();\n      }\n    }\n  }, {\n    key: 'name',\n    get: function get() {\n      return this._name;\n    }\n  }, {\n    key: 'items',\n    get: function get() {\n      var self = this;\n      var items = [];\n\n      if (!self._map) {\n        return items;\n      }\n\n      self._map.eachLayer(function (v, k) {\n        if (self.getData(v)) {\n          items.push(v);\n        }\n      });\n\n      return items;\n    }\n\n    /**\n     * get last item added\n     * @return {object} last item added\n     */\n\n  }, {\n    key: 'latestItem',\n    get: function get() {\n      return this.getMapData(this._latestItem);\n    }\n  }]);\n\n  return Limapper;\n}();\n\nexports.default = Limapper;\nmodule.exports = exports['default'];\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\nvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n(function (factory, window) {\n    /*globals define, module, require*/\n\n    // define an AMD module that relies on 'leaflet'\n    if (true) {\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n    // define a Common JS module that relies on 'leaflet'\n    } else if (typeof exports === 'object') {\n        module.exports = factory(require('leaflet'));\n    }\n\n    // attach your plugin to the global 'L' variable\n    if(typeof window !== 'undefined' && window.L){\n        factory(window.L);\n    }\n\n}(function (L) {\n    // 🍂miniclass CancelableEvent (Event objects)\n    // 🍂method cancel()\n    // Cancel any subsequent action.\n\n    // 🍂miniclass VertexEvent (Event objects)\n    // 🍂property vertex: VertexMarker\n    // The vertex that fires the event.\n\n    // 🍂miniclass ShapeEvent (Event objects)\n    // 🍂property shape: Array\n    // The shape (LatLngs array) subject of the action.\n\n    // 🍂miniclass CancelableVertexEvent (Event objects)\n    // 🍂inherits VertexEvent\n    // 🍂inherits CancelableEvent\n\n    // 🍂miniclass CancelableShapeEvent (Event objects)\n    // 🍂inherits ShapeEvent\n    // 🍂inherits CancelableEvent\n\n    // 🍂miniclass LayerEvent (Event objects)\n    // 🍂property layer: object\n    // The Layer (Marker, Polyline…) subject of the action.\n\n    // 🍂namespace Editable; 🍂class Editable; 🍂aka L.Editable\n    // Main edition handler. By default, it is attached to the map\n    // as `map.editTools` property.\n    // Leaflet.Editable is made to be fully extendable. You have three ways to customize\n    // the behaviour: using options, listening to events, or extending.\n    L.Editable = L.Evented.extend({\n\n        statics: {\n            FORWARD: 1,\n            BACKWARD: -1\n        },\n\n        options: {\n\n            // You can pass them when creating a map using the `editOptions` key.\n            // 🍂option zIndex: int = 1000\n            // The default zIndex of the editing tools.\n            zIndex: 1000,\n\n            // 🍂option polygonClass: class = L.Polygon\n            // Class to be used when creating a new Polygon.\n            polygonClass: L.Polygon,\n\n            // 🍂option polylineClass: class = L.Polyline\n            // Class to be used when creating a new Polyline.\n            polylineClass: L.Polyline,\n\n            // 🍂option markerClass: class = L.Marker\n            // Class to be used when creating a new Marker.\n            markerClass: L.Marker,\n\n            // 🍂option rectangleClass: class = L.Rectangle\n            // Class to be used when creating a new Rectangle.\n            rectangleClass: L.Rectangle,\n\n            // 🍂option circleClass: class = L.Circle\n            // Class to be used when creating a new Circle.\n            circleClass: L.Circle,\n\n            // 🍂option drawingCSSClass: string = 'leaflet-editable-drawing'\n            // CSS class to be added to the map container while drawing.\n            drawingCSSClass: 'leaflet-editable-drawing',\n\n            // 🍂option drawingCursor: const = 'crosshair'\n            // Cursor mode set to the map while drawing.\n            drawingCursor: 'crosshair',\n\n            // 🍂option editLayer: Layer = new L.LayerGroup()\n            // Layer used to store edit tools (vertex, line guide…).\n            editLayer: undefined,\n\n            // 🍂option featuresLayer: Layer = new L.LayerGroup()\n            // Default layer used to store drawn features (Marker, Polyline…).\n            featuresLayer: undefined,\n\n            // 🍂option polylineEditorClass: class = PolylineEditor\n            // Class to be used as Polyline editor.\n            polylineEditorClass: undefined,\n\n            // 🍂option polygonEditorClass: class = PolygonEditor\n            // Class to be used as Polygon editor.\n            polygonEditorClass: undefined,\n\n            // 🍂option markerEditorClass: class = MarkerEditor\n            // Class to be used as Marker editor.\n            markerEditorClass: undefined,\n\n            // 🍂option rectangleEditorClass: class = RectangleEditor\n            // Class to be used as Rectangle editor.\n            rectangleEditorClass: undefined,\n\n            // 🍂option circleEditorClass: class = CircleEditor\n            // Class to be used as Circle editor.\n            circleEditorClass: undefined,\n\n            // 🍂option lineGuideOptions: hash = {}\n            // Options to be passed to the line guides.\n            lineGuideOptions: {},\n\n            // 🍂option skipMiddleMarkers: boolean = false\n            // Set this to true if you don't want middle markers.\n            skipMiddleMarkers: false\n\n        },\n\n        initialize: function (map, options) {\n            L.setOptions(this, options);\n            this._lastZIndex = this.options.zIndex;\n            this.map = map;\n            this.editLayer = this.createEditLayer();\n            this.featuresLayer = this.createFeaturesLayer();\n            this.forwardLineGuide = this.createLineGuide();\n            this.backwardLineGuide = this.createLineGuide();\n        },\n\n        fireAndForward: function (type, e) {\n            e = e || {};\n            e.editTools = this;\n            this.fire(type, e);\n            this.map.fire(type, e);\n        },\n\n        createLineGuide: function () {\n            var options = L.extend({dashArray: '5,10', weight: 1, interactive: false}, this.options.lineGuideOptions);\n            return L.polyline([], options);\n        },\n\n        createVertexIcon: function (options) {\n            return L.Browser.touch ? new L.Editable.TouchVertexIcon(options) : new L.Editable.VertexIcon(options);\n        },\n\n        createEditLayer: function () {\n            return this.options.editLayer || new L.LayerGroup().addTo(this.map);\n        },\n\n        createFeaturesLayer: function () {\n            return this.options.featuresLayer || new L.LayerGroup().addTo(this.map);\n        },\n\n        moveForwardLineGuide: function (latlng) {\n            if (this.forwardLineGuide._latlngs.length) {\n                this.forwardLineGuide._latlngs[1] = latlng;\n                this.forwardLineGuide._bounds.extend(latlng);\n                this.forwardLineGuide.redraw();\n            }\n        },\n\n        moveBackwardLineGuide: function (latlng) {\n            if (this.backwardLineGuide._latlngs.length) {\n                this.backwardLineGuide._latlngs[1] = latlng;\n                this.backwardLineGuide._bounds.extend(latlng);\n                this.backwardLineGuide.redraw();\n            }\n        },\n\n        anchorForwardLineGuide: function (latlng) {\n            this.forwardLineGuide._latlngs[0] = latlng;\n            this.forwardLineGuide._bounds.extend(latlng);\n            this.forwardLineGuide.redraw();\n        },\n\n        anchorBackwardLineGuide: function (latlng) {\n            this.backwardLineGuide._latlngs[0] = latlng;\n            this.backwardLineGuide._bounds.extend(latlng);\n            this.backwardLineGuide.redraw();\n        },\n\n        attachForwardLineGuide: function () {\n            this.editLayer.addLayer(this.forwardLineGuide);\n        },\n\n        attachBackwardLineGuide: function () {\n            this.editLayer.addLayer(this.backwardLineGuide);\n        },\n\n        detachForwardLineGuide: function () {\n            this.forwardLineGuide.setLatLngs([]);\n            this.editLayer.removeLayer(this.forwardLineGuide);\n        },\n\n        detachBackwardLineGuide: function () {\n            this.backwardLineGuide.setLatLngs([]);\n            this.editLayer.removeLayer(this.backwardLineGuide);\n        },\n\n        blockEvents: function () {\n            // Hack: force map not to listen to other layers events while drawing.\n            if (!this._oldTargets) {\n                this._oldTargets = this.map._targets;\n                this.map._targets = {};\n            }\n        },\n\n        unblockEvents: function () {\n            if (this._oldTargets) {\n                // Reset, but keep targets created while drawing.\n                this.map._targets = L.extend(this.map._targets, this._oldTargets);\n                delete this._oldTargets;\n            }\n        },\n\n        registerForDrawing: function (editor) {\n            if (this._drawingEditor) this.unregisterForDrawing(this._drawingEditor);\n            this.blockEvents();\n            editor.reset();  // Make sure editor tools still receive events.\n            this._drawingEditor = editor;\n            this.map.on('mousemove touchmove', editor.onDrawingMouseMove, editor);\n            this.map.on('mousedown', this.onMousedown, this);\n            this.map.on('mouseup', this.onMouseup, this);\n            L.DomUtil.addClass(this.map._container, this.options.drawingCSSClass);\n            this.defaultMapCursor = this.map._container.style.cursor;\n            this.map._container.style.cursor = this.options.drawingCursor;\n        },\n\n        unregisterForDrawing: function (editor) {\n            this.unblockEvents();\n            L.DomUtil.removeClass(this.map._container, this.options.drawingCSSClass);\n            this.map._container.style.cursor = this.defaultMapCursor;\n            editor = editor || this._drawingEditor;\n            if (!editor) return;\n            this.map.off('mousemove touchmove', editor.onDrawingMouseMove, editor);\n            this.map.off('mousedown', this.onMousedown, this);\n            this.map.off('mouseup', this.onMouseup, this);\n            if (editor !== this._drawingEditor) return;\n            delete this._drawingEditor;\n            if (editor._drawing) editor.cancelDrawing();\n        },\n\n        onMousedown: function (e) {\n            this._mouseDown = e;\n            this._drawingEditor.onDrawingMouseDown(e);\n        },\n\n        onMouseup: function (e) {\n            if (this._mouseDown) {\n                var editor = this._drawingEditor,\n                    mouseDown = this._mouseDown;\n                this._mouseDown = null;\n                editor.onDrawingMouseUp(e);\n                if (this._drawingEditor !== editor) return;  // onDrawingMouseUp may call unregisterFromDrawing.\n                var origin = L.point(mouseDown.originalEvent.clientX, mouseDown.originalEvent.clientY);\n                var distance = L.point(e.originalEvent.clientX, e.originalEvent.clientY).distanceTo(origin);\n                if (Math.abs(distance) < 9 * (window.devicePixelRatio || 1)) this._drawingEditor.onDrawingClick(e);\n            }\n        },\n\n        // 🍂section Public methods\n        // You will generally access them by the `map.editTools`\n        // instance:\n        //\n        // `map.editTools.startPolyline();`\n\n        // 🍂method drawing(): boolean\n        // Return true if any drawing action is ongoing.\n        drawing: function () {\n            return this._drawingEditor && this._drawingEditor.drawing();\n        },\n\n        // 🍂method stopDrawing()\n        // When you need to stop any ongoing drawing, without needing to know which editor is active.\n        stopDrawing: function () {\n            this.unregisterForDrawing();\n        },\n\n        // 🍂method commitDrawing()\n        // When you need to commit any ongoing drawing, without needing to know which editor is active.\n        commitDrawing: function (e) {\n            if (!this._drawingEditor) return;\n            this._drawingEditor.commitDrawing(e);\n        },\n\n        connectCreatedToMap: function (layer) {\n            return this.featuresLayer.addLayer(layer);\n        },\n\n        // 🍂method startPolyline(latlng: L.LatLng, options: hash): L.Polyline\n        // Start drawing a Polyline. If `latlng` is given, a first point will be added. In any case, continuing on user click.\n        // If `options` is given, it will be passed to the Polyline class constructor.\n        startPolyline: function (latlng, options) {\n            var line = this.createPolyline([], options);\n            line.enableEdit(this.map).newShape(latlng);\n            return line;\n        },\n\n        // 🍂method startPolygon(latlng: L.LatLng, options: hash): L.Polygon\n        // Start drawing a Polygon. If `latlng` is given, a first point will be added. In any case, continuing on user click.\n        // If `options` is given, it will be passed to the Polygon class constructor.\n        startPolygon: function (latlng, options) {\n            var polygon = this.createPolygon([], options);\n            polygon.enableEdit(this.map).newShape(latlng);\n            return polygon;\n        },\n\n        // 🍂method startMarker(latlng: L.LatLng, options: hash): L.Marker\n        // Start adding a Marker. If `latlng` is given, the Marker will be shown first at this point.\n        // In any case, it will follow the user mouse, and will have a final `latlng` on next click (or touch).\n        // If `options` is given, it will be passed to the Marker class constructor.\n        startMarker: function (latlng, options) {\n            latlng = latlng || this.map.getCenter().clone();\n            var marker = this.createMarker(latlng, options);\n            marker.enableEdit(this.map).startDrawing();\n            return marker;\n        },\n\n        // 🍂method startRectangle(latlng: L.LatLng, options: hash): L.Rectangle\n        // Start drawing a Rectangle. If `latlng` is given, the Rectangle anchor will be added. In any case, continuing on user drag.\n        // If `options` is given, it will be passed to the Rectangle class constructor.\n        startRectangle: function(latlng, options) {\n            var corner = latlng || L.latLng([0, 0]);\n            var bounds = new L.LatLngBounds(corner, corner);\n            var rectangle = this.createRectangle(bounds, options);\n            rectangle.enableEdit(this.map).startDrawing();\n            return rectangle;\n        },\n\n        // 🍂method startCircle(latlng: L.LatLng, options: hash): L.Circle\n        // Start drawing a Circle. If `latlng` is given, the Circle anchor will be added. In any case, continuing on user drag.\n        // If `options` is given, it will be passed to the Circle class constructor.\n        startCircle: function (latlng, options) {\n            latlng = latlng || this.map.getCenter().clone();\n            var circle = this.createCircle(latlng, options);\n            circle.enableEdit(this.map).startDrawing();\n            return circle;\n        },\n\n        startHole: function (editor, latlng) {\n            editor.newHole(latlng);\n        },\n\n        createLayer: function (klass, latlngs, options) {\n            options = L.Util.extend({editOptions: {editTools: this}}, options);\n            var layer = new klass(latlngs, options);\n            // 🍂namespace Editable\n            // 🍂event editable:created: LayerEvent\n            // Fired when a new feature (Marker, Polyline…) is created.\n            this.fireAndForward('editable:created', {layer: layer});\n            return layer;\n        },\n\n        createPolyline: function (latlngs, options) {\n            return this.createLayer(options && options.polylineClass || this.options.polylineClass, latlngs, options);\n        },\n\n        createPolygon: function (latlngs, options) {\n            return this.createLayer(options && options.polygonClass || this.options.polygonClass, latlngs, options);\n        },\n\n        createMarker: function (latlng, options) {\n            return this.createLayer(options && options.markerClass || this.options.markerClass, latlng, options);\n        },\n\n        createRectangle: function (bounds, options) {\n            return this.createLayer(options && options.rectangleClass || this.options.rectangleClass, bounds, options);\n        },\n\n        createCircle: function (latlng, options) {\n            return this.createLayer(options && options.circleClass || this.options.circleClass, latlng, options);\n        }\n\n    });\n\n    L.extend(L.Editable, {\n\n        makeCancellable: function (e) {\n            e.cancel = function () {\n                e._cancelled = true;\n            };\n        }\n\n    });\n\n    // 🍂namespace Map; 🍂class Map\n    // Leaflet.Editable add options and events to the `L.Map` object.\n    // See `Editable` events for the list of events fired on the Map.\n    // 🍂example\n    //\n    // ```js\n    // var map = L.map('map', {\n    //  editable: true,\n    //  editOptions: {\n    //    …\n    // }\n    // });\n    // ```\n    // 🍂section Editable Map Options\n    L.Map.mergeOptions({\n\n        // 🍂namespace Map\n        // 🍂section Map Options\n        // 🍂option editToolsClass: class = L.Editable\n        // Class to be used as vertex, for path editing.\n        editToolsClass: L.Editable,\n\n        // 🍂option editable: boolean = false\n        // Whether to create a L.Editable instance at map init.\n        editable: false,\n\n        // 🍂option editOptions: hash = {}\n        // Options to pass to L.Editable when instanciating.\n        editOptions: {}\n\n    });\n\n    L.Map.addInitHook(function () {\n\n        this.whenReady(function () {\n            if (this.options.editable) {\n                this.editTools = new this.options.editToolsClass(this, this.options.editOptions);\n            }\n        });\n\n    });\n\n    L.Editable.VertexIcon = L.DivIcon.extend({\n\n        options: {\n            iconSize: new L.Point(8, 8)\n        }\n\n    });\n\n    L.Editable.TouchVertexIcon = L.Editable.VertexIcon.extend({\n\n        options: {\n            iconSize: new L.Point(20, 20)\n        }\n\n    });\n\n\n    // 🍂namespace Editable; 🍂class VertexMarker; Handler for dragging path vertices.\n    L.Editable.VertexMarker = L.Marker.extend({\n\n        options: {\n            draggable: true,\n            className: 'leaflet-div-icon leaflet-vertex-icon'\n        },\n\n\n        // 🍂section Public methods\n        // The marker used to handle path vertex. You will usually interact with a `VertexMarker`\n        // instance when listening for events like `editable:vertex:ctrlclick`.\n\n        initialize: function (latlng, latlngs, editor, options) {\n            // We don't use this._latlng, because on drag Leaflet replace it while\n            // we want to keep reference.\n            this.latlng = latlng;\n            this.latlngs = latlngs;\n            this.editor = editor;\n            L.Marker.prototype.initialize.call(this, latlng, options);\n            this.options.icon = this.editor.tools.createVertexIcon({className: this.options.className});\n            this.latlng.__vertex = this;\n            this.editor.editLayer.addLayer(this);\n            this.setZIndexOffset(editor.tools._lastZIndex + 1);\n        },\n\n        onAdd: function (map) {\n            L.Marker.prototype.onAdd.call(this, map);\n            this.on('drag', this.onDrag);\n            this.on('dragstart', this.onDragStart);\n            this.on('dragend', this.onDragEnd);\n            this.on('mouseup', this.onMouseup);\n            this.on('click', this.onClick);\n            this.on('contextmenu', this.onContextMenu);\n            this.on('mousedown touchstart', this.onMouseDown);\n            this.addMiddleMarkers();\n        },\n\n        onRemove: function (map) {\n            if (this.middleMarker) this.middleMarker.delete();\n            delete this.latlng.__vertex;\n            this.off('drag', this.onDrag);\n            this.off('dragstart', this.onDragStart);\n            this.off('dragend', this.onDragEnd);\n            this.off('mouseup', this.onMouseup);\n            this.off('click', this.onClick);\n            this.off('contextmenu', this.onContextMenu);\n            this.off('mousedown touchstart', this.onMouseDown);\n            L.Marker.prototype.onRemove.call(this, map);\n        },\n\n        onDrag: function (e) {\n            e.vertex = this;\n            this.editor.onVertexMarkerDrag(e);\n            var iconPos = L.DomUtil.getPosition(this._icon),\n                latlng = this._map.layerPointToLatLng(iconPos);\n            this.latlng.update(latlng);\n            this._latlng = this.latlng;  // Push back to Leaflet our reference.\n            this.editor.refresh();\n            if (this.middleMarker) this.middleMarker.updateLatLng();\n            var next = this.getNext();\n            if (next && next.middleMarker) next.middleMarker.updateLatLng();\n        },\n\n        onDragStart: function (e) {\n            e.vertex = this;\n            this.editor.onVertexMarkerDragStart(e);\n        },\n\n        onDragEnd: function (e) {\n            e.vertex = this;\n            this.editor.onVertexMarkerDragEnd(e);\n        },\n\n        onClick: function (e) {\n            e.vertex = this;\n            this.editor.onVertexMarkerClick(e);\n        },\n\n        onMouseup: function (e) {\n            L.DomEvent.stop(e);\n            e.vertex = this;\n            this.editor.map.fire('mouseup', e);\n        },\n\n        onContextMenu: function (e) {\n            e.vertex = this;\n            this.editor.onVertexMarkerContextMenu(e);\n        },\n\n        onMouseDown: function (e) {\n            e.vertex = this;\n            this.editor.onVertexMarkerMouseDown(e);\n        },\n\n        // 🍂method delete()\n        // Delete a vertex and the related LatLng.\n        delete: function () {\n            var next = this.getNext();  // Compute before changing latlng\n            this.latlngs.splice(this.getIndex(), 1);\n            this.editor.editLayer.removeLayer(this);\n            this.editor.onVertexDeleted({latlng: this.latlng, vertex: this});\n            if (!this.latlngs.length) this.editor.deleteShape(this.latlngs);\n            if (next) next.resetMiddleMarker();\n            this.editor.refresh();\n        },\n\n        // 🍂method getIndex(): int\n        // Get the index of the current vertex among others of the same LatLngs group.\n        getIndex: function () {\n            return this.latlngs.indexOf(this.latlng);\n        },\n\n        // 🍂method getLastIndex(): int\n        // Get last vertex index of the LatLngs group of the current vertex.\n        getLastIndex: function () {\n            return this.latlngs.length - 1;\n        },\n\n        // 🍂method getPrevious(): VertexMarker\n        // Get the previous VertexMarker in the same LatLngs group.\n        getPrevious: function () {\n            if (this.latlngs.length < 2) return;\n            var index = this.getIndex(),\n                previousIndex = index - 1;\n            if (index === 0 && this.editor.CLOSED) previousIndex = this.getLastIndex();\n            var previous = this.latlngs[previousIndex];\n            if (previous) return previous.__vertex;\n        },\n\n        // 🍂method getNext(): VertexMarker\n        // Get the next VertexMarker in the same LatLngs group.\n        getNext: function () {\n            if (this.latlngs.length < 2) return;\n            var index = this.getIndex(),\n                nextIndex = index + 1;\n            if (index === this.getLastIndex() && this.editor.CLOSED) nextIndex = 0;\n            var next = this.latlngs[nextIndex];\n            if (next) return next.__vertex;\n        },\n\n        addMiddleMarker: function (previous) {\n            if (!this.editor.hasMiddleMarkers()) return;\n            previous = previous || this.getPrevious();\n            if (previous && !this.middleMarker) this.middleMarker = this.editor.addMiddleMarker(previous, this, this.latlngs, this.editor);\n        },\n\n        addMiddleMarkers: function () {\n            if (!this.editor.hasMiddleMarkers()) return;\n            var previous = this.getPrevious();\n            if (previous) this.addMiddleMarker(previous);\n            var next = this.getNext();\n            if (next) next.resetMiddleMarker();\n        },\n\n        resetMiddleMarker: function () {\n            if (this.middleMarker) this.middleMarker.delete();\n            this.addMiddleMarker();\n        },\n\n        // 🍂method split()\n        // Split the vertex LatLngs group at its index, if possible.\n        split: function () {\n            if (!this.editor.splitShape) return;  // Only for PolylineEditor\n            this.editor.splitShape(this.latlngs, this.getIndex());\n        },\n\n        // 🍂method continue()\n        // Continue the vertex LatLngs from this vertex. Only active for first and last vertices of a Polyline.\n        continue: function () {\n            if (!this.editor.continueBackward) return;  // Only for PolylineEditor\n            var index = this.getIndex();\n            if (index === 0) this.editor.continueBackward(this.latlngs);\n            else if (index === this.getLastIndex()) this.editor.continueForward(this.latlngs);\n        }\n\n    });\n\n    L.Editable.mergeOptions({\n\n        // 🍂namespace Editable\n        // 🍂option vertexMarkerClass: class = VertexMarker\n        // Class to be used as vertex, for path editing.\n        vertexMarkerClass: L.Editable.VertexMarker\n\n    });\n\n    L.Editable.MiddleMarker = L.Marker.extend({\n\n        options: {\n            opacity: 0.5,\n            className: 'leaflet-div-icon leaflet-middle-icon',\n            draggable: true\n        },\n\n        initialize: function (left, right, latlngs, editor, options) {\n            this.left = left;\n            this.right = right;\n            this.editor = editor;\n            this.latlngs = latlngs;\n            L.Marker.prototype.initialize.call(this, this.computeLatLng(), options);\n            this._opacity = this.options.opacity;\n            this.options.icon = this.editor.tools.createVertexIcon({className: this.options.className});\n            this.editor.editLayer.addLayer(this);\n            this.setVisibility();\n        },\n\n        setVisibility: function () {\n            var leftPoint = this._map.latLngToContainerPoint(this.left.latlng),\n                rightPoint = this._map.latLngToContainerPoint(this.right.latlng),\n                size = L.point(this.options.icon.options.iconSize);\n            if (leftPoint.distanceTo(rightPoint) < size.x * 3) this.hide();\n            else this.show();\n        },\n\n        show: function () {\n            this.setOpacity(this._opacity);\n        },\n\n        hide: function () {\n            this.setOpacity(0);\n        },\n\n        updateLatLng: function () {\n            this.setLatLng(this.computeLatLng());\n            this.setVisibility();\n        },\n\n        computeLatLng: function () {\n            var leftPoint = this.editor.map.latLngToContainerPoint(this.left.latlng),\n                rightPoint = this.editor.map.latLngToContainerPoint(this.right.latlng),\n                y = (leftPoint.y + rightPoint.y) / 2,\n                x = (leftPoint.x + rightPoint.x) / 2;\n            return this.editor.map.containerPointToLatLng([x, y]);\n        },\n\n        onAdd: function (map) {\n            L.Marker.prototype.onAdd.call(this, map);\n            L.DomEvent.on(this._icon, 'mousedown touchstart', this.onMouseDown, this);\n            map.on('zoomend', this.setVisibility, this);\n        },\n\n        onRemove: function (map) {\n            delete this.right.middleMarker;\n            L.DomEvent.off(this._icon, 'mousedown touchstart', this.onMouseDown, this);\n            map.off('zoomend', this.setVisibility, this);\n            L.Marker.prototype.onRemove.call(this, map);\n        },\n\n        onMouseDown: function (e) {\n            var iconPos = L.DomUtil.getPosition(this._icon),\n                latlng = this.editor.map.layerPointToLatLng(iconPos);\n            e = {\n                originalEvent: e,\n                latlng: latlng\n            };\n            if (this.options.opacity === 0) return;\n            L.Editable.makeCancellable(e);\n            this.editor.onMiddleMarkerMouseDown(e);\n            if (e._cancelled) return;\n            this.latlngs.splice(this.index(), 0, e.latlng);\n            this.editor.refresh();\n            var icon = this._icon;\n            var marker = this.editor.addVertexMarker(e.latlng, this.latlngs);\n            /* Hack to workaround browser not firing touchend when element is no more on DOM */\n            var parent = marker._icon.parentNode;\n            parent.removeChild(marker._icon);\n            marker._icon = icon;\n            parent.appendChild(marker._icon);\n            marker._initIcon();\n            marker._initInteraction();\n            marker.setOpacity(1);\n            /* End hack */\n            // Transfer ongoing dragging to real marker\n            L.Draggable._dragging = false;\n            marker.dragging._draggable._onDown(e.originalEvent);\n            this.delete();\n        },\n\n        delete: function () {\n            this.editor.editLayer.removeLayer(this);\n        },\n\n        index: function () {\n            return this.latlngs.indexOf(this.right.latlng);\n        }\n\n    });\n\n    L.Editable.mergeOptions({\n\n        // 🍂namespace Editable\n        // 🍂option middleMarkerClass: class = VertexMarker\n        // Class to be used as middle vertex, pulled by the user to create a new point in the middle of a path.\n        middleMarkerClass: L.Editable.MiddleMarker\n\n    });\n\n    // 🍂namespace Editable; 🍂class BaseEditor; 🍂aka L.Editable.BaseEditor\n    // When editing a feature (Marker, Polyline…), an editor is attached to it. This\n    // editor basically knows how to handle the edition.\n    L.Editable.BaseEditor = L.Handler.extend({\n\n        initialize: function (map, feature, options) {\n            L.setOptions(this, options);\n            this.map = map;\n            this.feature = feature;\n            this.feature.editor = this;\n            this.editLayer = new L.LayerGroup();\n            this.tools = this.options.editTools || map.editTools;\n        },\n\n        // 🍂method enable(): this\n        // Set up the drawing tools for the feature to be editable.\n        addHooks: function () {\n            if (this.isConnected()) this.onFeatureAdd();\n            else this.feature.once('add', this.onFeatureAdd, this);\n            this.onEnable();\n            this.feature.on(this._getEvents(), this);\n            return;\n        },\n\n        // 🍂method disable(): this\n        // Remove the drawing tools for the feature.\n        removeHooks: function () {\n            this.feature.off(this._getEvents(), this);\n            if (this.feature.dragging) this.feature.dragging.disable();\n            this.editLayer.clearLayers();\n            this.tools.editLayer.removeLayer(this.editLayer);\n            this.onDisable();\n            if (this._drawing) this.cancelDrawing();\n            return;\n        },\n\n        // 🍂method drawing(): boolean\n        // Return true if any drawing action is ongoing with this editor.\n        drawing: function () {\n            return !!this._drawing;\n        },\n\n        reset: function () {},\n\n        onFeatureAdd: function () {\n            this.tools.editLayer.addLayer(this.editLayer);\n            if (this.feature.dragging) this.feature.dragging.enable();\n        },\n\n        hasMiddleMarkers: function () {\n            return !this.options.skipMiddleMarkers && !this.tools.options.skipMiddleMarkers;\n        },\n\n        fireAndForward: function (type, e) {\n            e = e || {};\n            e.layer = this.feature;\n            this.feature.fire(type, e);\n            this.tools.fireAndForward(type, e);\n        },\n\n        onEnable: function () {\n            // 🍂namespace Editable\n            // 🍂event editable:enable: Event\n            // Fired when an existing feature is ready to be edited.\n            this.fireAndForward('editable:enable');\n        },\n\n        onDisable: function () {\n            // 🍂namespace Editable\n            // 🍂event editable:disable: Event\n            // Fired when an existing feature is not ready anymore to be edited.\n            this.fireAndForward('editable:disable');\n        },\n\n        onEditing: function () {\n            // 🍂namespace Editable\n            // 🍂event editable:editing: Event\n            // Fired as soon as any change is made to the feature geometry.\n            this.fireAndForward('editable:editing');\n        },\n\n        onStartDrawing: function () {\n            // 🍂namespace Editable\n            // 🍂section Drawing events\n            // 🍂event editable:drawing:start: Event\n            // Fired when a feature is to be drawn.\n            this.fireAndForward('editable:drawing:start');\n        },\n\n        onEndDrawing: function () {\n            // 🍂namespace Editable\n            // 🍂section Drawing events\n            // 🍂event editable:drawing:end: Event\n            // Fired when a feature is not drawn anymore.\n            this.fireAndForward('editable:drawing:end');\n        },\n\n        onCancelDrawing: function () {\n            // 🍂namespace Editable\n            // 🍂section Drawing events\n            // 🍂event editable:drawing:cancel: Event\n            // Fired when user cancel drawing while a feature is being drawn.\n            this.fireAndForward('editable:drawing:cancel');\n        },\n\n        onCommitDrawing: function (e) {\n            // 🍂namespace Editable\n            // 🍂section Drawing events\n            // 🍂event editable:drawing:commit: Event\n            // Fired when user finish drawing a feature.\n            this.fireAndForward('editable:drawing:commit', e);\n        },\n\n        onDrawingMouseDown: function (e) {\n            // 🍂namespace Editable\n            // 🍂section Drawing events\n            // 🍂event editable:drawing:mousedown: Event\n            // Fired when user `mousedown` while drawing.\n            this.fireAndForward('editable:drawing:mousedown', e);\n        },\n\n        onDrawingMouseUp: function (e) {\n            // 🍂namespace Editable\n            // 🍂section Drawing events\n            // 🍂event editable:drawing:mouseup: Event\n            // Fired when user `mouseup` while drawing.\n            this.fireAndForward('editable:drawing:mouseup', e);\n        },\n\n        startDrawing: function () {\n            if (!this._drawing) this._drawing = L.Editable.FORWARD;\n            this.tools.registerForDrawing(this);\n            this.onStartDrawing();\n        },\n\n        commitDrawing: function (e) {\n            this.onCommitDrawing(e);\n            this.endDrawing();\n        },\n\n        cancelDrawing: function () {\n            // If called during a vertex drag, the vertex will be removed before\n            // the mouseup fires on it. This is a workaround. Maybe better fix is\n            // To have L.Draggable reset it's status on disable (Leaflet side).\n            L.Draggable._dragging = false;\n            this.onCancelDrawing();\n            this.endDrawing();\n        },\n\n        endDrawing: function () {\n            this._drawing = false;\n            this.tools.unregisterForDrawing(this);\n            this.onEndDrawing();\n        },\n\n        onDrawingClick: function (e) {\n            if (!this.drawing()) return;\n            L.Editable.makeCancellable(e);\n            // 🍂namespace Editable\n            // 🍂section Drawing events\n            // 🍂event editable:drawing:click: CancelableEvent\n            // Fired when user `click` while drawing, before any internal action is being processed.\n            this.fireAndForward('editable:drawing:click', e);\n            if (e._cancelled) return;\n            if (!this.isConnected()) this.connect(e);\n            this.processDrawingClick(e);\n        },\n\n        isConnected: function () {\n            return this.map.hasLayer(this.feature);\n        },\n\n        connect: function (e) {\n            this.tools.connectCreatedToMap(this.feature);\n            this.tools.editLayer.addLayer(this.editLayer);\n        },\n\n        onMove: function (e) {\n            // 🍂namespace Editable\n            // 🍂section Drawing events\n            // 🍂event editable:drawing:move: Event\n            // Fired when `move` mouse while drawing, while dragging a marker, and while dragging a vertex.\n            this.fireAndForward('editable:drawing:move', e);\n        },\n\n        onDrawingMouseMove: function (e) {\n            this.onMove(e);\n        },\n\n        _getEvents: function () {\n            return {\n                dragstart: this.onDragStart,\n                drag: this.onDrag,\n                dragend: this.onDragEnd,\n                remove: this.disable\n            };\n        },\n\n        onDragStart: function (e) {\n            this.onEditing();\n            // 🍂namespace Editable\n            // 🍂event editable:dragstart: Event\n            // Fired before a path feature is dragged.\n            this.fireAndForward('editable:dragstart', e);\n        },\n\n        onDrag: function (e) {\n            this.onMove(e);\n            // 🍂namespace Editable\n            // 🍂event editable:drag: Event\n            // Fired when a path feature is being dragged.\n            this.fireAndForward('editable:drag', e);\n        },\n\n        onDragEnd: function (e) {\n            // 🍂namespace Editable\n            // 🍂event editable:dragend: Event\n            // Fired after a path feature has been dragged.\n            this.fireAndForward('editable:dragend', e);\n        }\n\n    });\n\n    // 🍂namespace Editable; 🍂class MarkerEditor; 🍂aka L.Editable.MarkerEditor\n    // 🍂inherits BaseEditor\n    // Editor for Marker.\n    L.Editable.MarkerEditor = L.Editable.BaseEditor.extend({\n\n        onDrawingMouseMove: function (e) {\n            L.Editable.BaseEditor.prototype.onDrawingMouseMove.call(this, e);\n            if (this._drawing) this.feature.setLatLng(e.latlng);\n        },\n\n        processDrawingClick: function (e) {\n            // 🍂namespace Editable\n            // 🍂section Drawing events\n            // 🍂event editable:drawing:clicked: Event\n            // Fired when user `click` while drawing, after all internal actions.\n            this.fireAndForward('editable:drawing:clicked', e);\n            this.commitDrawing(e);\n        },\n\n        connect: function (e) {\n            // On touch, the latlng has not been updated because there is\n            // no mousemove.\n            if (e) this.feature._latlng = e.latlng;\n            L.Editable.BaseEditor.prototype.connect.call(this, e);\n        }\n\n    });\n\n    // 🍂namespace Editable; 🍂class PathEditor; 🍂aka L.Editable.PathEditor\n    // 🍂inherits BaseEditor\n    // Base class for all path editors.\n    L.Editable.PathEditor = L.Editable.BaseEditor.extend({\n\n        CLOSED: false,\n        MIN_VERTEX: 2,\n\n        addHooks: function () {\n            L.Editable.BaseEditor.prototype.addHooks.call(this);\n            if (this.feature) this.initVertexMarkers();\n            return this;\n        },\n\n        initVertexMarkers: function (latlngs) {\n            if (!this.enabled()) return;\n            latlngs = latlngs || this.getLatLngs();\n            if (L.Polyline._flat(latlngs)) this.addVertexMarkers(latlngs);\n            else for (var i = 0; i < latlngs.length; i++) this.initVertexMarkers(latlngs[i]);\n        },\n\n        getLatLngs: function () {\n            return this.feature.getLatLngs();\n        },\n\n        // 🍂method reset()\n        // Rebuild edit elements (Vertex, MiddleMarker, etc.).\n        reset: function () {\n            this.editLayer.clearLayers();\n            this.initVertexMarkers();\n        },\n\n        addVertexMarker: function (latlng, latlngs) {\n            return new this.tools.options.vertexMarkerClass(latlng, latlngs, this);\n        },\n\n        addVertexMarkers: function (latlngs) {\n            for (var i = 0; i < latlngs.length; i++) {\n                this.addVertexMarker(latlngs[i], latlngs);\n            }\n        },\n\n        refreshVertexMarkers: function (latlngs) {\n            latlngs = latlngs || this.getDefaultLatLngs();\n            for (var i = 0; i < latlngs.length; i++) {\n                latlngs[i].__vertex.update();\n            }\n        },\n\n        addMiddleMarker: function (left, right, latlngs) {\n            return new this.tools.options.middleMarkerClass(left, right, latlngs, this);\n        },\n\n        onVertexMarkerClick: function (e) {\n            L.Editable.makeCancellable(e);\n            // 🍂namespace Editable\n            // 🍂section Vertex events\n            // 🍂event editable:vertex:click: CancelableVertexEvent\n            // Fired when a `click` is issued on a vertex, before any internal action is being processed.\n            this.fireAndForward('editable:vertex:click', e);\n            if (e._cancelled) return;\n            if (this.tools.drawing() && this.tools._drawingEditor !== this) return;\n            var index = e.vertex.getIndex(), commit;\n            if (e.originalEvent.ctrlKey) {\n                this.onVertexMarkerCtrlClick(e);\n            } else if (e.originalEvent.altKey) {\n                this.onVertexMarkerAltClick(e);\n            } else if (e.originalEvent.shiftKey) {\n                this.onVertexMarkerShiftClick(e);\n            } else if (e.originalEvent.metaKey) {\n                this.onVertexMarkerMetaKeyClick(e);\n            } else if (index === e.vertex.getLastIndex() && this._drawing === L.Editable.FORWARD) {\n                if (index >= this.MIN_VERTEX - 1) commit = true;\n            } else if (index === 0 && this._drawing === L.Editable.BACKWARD && this._drawnLatLngs.length >= this.MIN_VERTEX) {\n                commit = true;\n            } else if (index === 0 && this._drawing === L.Editable.FORWARD && this._drawnLatLngs.length >= this.MIN_VERTEX && this.CLOSED) {\n                commit = true;  // Allow to close on first point also for polygons\n            } else {\n                this.onVertexRawMarkerClick(e);\n            }\n            // 🍂namespace Editable\n            // 🍂section Vertex events\n            // 🍂event editable:vertex:clicked: VertexEvent\n            // Fired when a `click` is issued on a vertex, after all internal actions.\n            this.fireAndForward('editable:vertex:clicked', e);\n            if (commit) this.commitDrawing(e);\n        },\n\n        onVertexRawMarkerClick: function (e) {\n            // 🍂namespace Editable\n            // 🍂section Vertex events\n            // 🍂event editable:vertex:rawclick: CancelableVertexEvent\n            // Fired when a `click` is issued on a vertex without any special key and without being in drawing mode.\n            this.fireAndForward('editable:vertex:rawclick', e);\n            if (e._cancelled) return;\n            if (!this.vertexCanBeDeleted(e.vertex)) return;\n            e.vertex.delete();\n        },\n\n        vertexCanBeDeleted: function (vertex) {\n            return vertex.latlngs.length > this.MIN_VERTEX;\n        },\n\n        onVertexDeleted: function (e) {\n            // 🍂namespace Editable\n            // 🍂section Vertex events\n            // 🍂event editable:vertex:deleted: VertexEvent\n            // Fired after a vertex has been deleted by user.\n            this.fireAndForward('editable:vertex:deleted', e);\n        },\n\n        onVertexMarkerCtrlClick: function (e) {\n            // 🍂namespace Editable\n            // 🍂section Vertex events\n            // 🍂event editable:vertex:ctrlclick: VertexEvent\n            // Fired when a `click` with `ctrlKey` is issued on a vertex.\n            this.fireAndForward('editable:vertex:ctrlclick', e);\n        },\n\n        onVertexMarkerShiftClick: function (e) {\n            // 🍂namespace Editable\n            // 🍂section Vertex events\n            // 🍂event editable:vertex:shiftclick: VertexEvent\n            // Fired when a `click` with `shiftKey` is issued on a vertex.\n            this.fireAndForward('editable:vertex:shiftclick', e);\n        },\n\n        onVertexMarkerMetaKeyClick: function (e) {\n            // 🍂namespace Editable\n            // 🍂section Vertex events\n            // 🍂event editable:vertex:metakeyclick: VertexEvent\n            // Fired when a `click` with `metaKey` is issued on a vertex.\n            this.fireAndForward('editable:vertex:metakeyclick', e);\n        },\n\n        onVertexMarkerAltClick: function (e) {\n            // 🍂namespace Editable\n            // 🍂section Vertex events\n            // 🍂event editable:vertex:altclick: VertexEvent\n            // Fired when a `click` with `altKey` is issued on a vertex.\n            this.fireAndForward('editable:vertex:altclick', e);\n        },\n\n        onVertexMarkerContextMenu: function (e) {\n            // 🍂namespace Editable\n            // 🍂section Vertex events\n            // 🍂event editable:vertex:contextmenu: VertexEvent\n            // Fired when a `contextmenu` is issued on a vertex.\n            this.fireAndForward('editable:vertex:contextmenu', e);\n        },\n\n        onVertexMarkerMouseDown: function (e) {\n            // 🍂namespace Editable\n            // 🍂section Vertex events\n            // 🍂event editable:vertex:mousedown: VertexEvent\n            // Fired when user `mousedown` a vertex.\n            this.fireAndForward('editable:vertex:mousedown', e);\n        },\n\n        onMiddleMarkerMouseDown: function (e) {\n            // 🍂namespace Editable\n            // 🍂section MiddleMarker events\n            // 🍂event editable:middlemarker:mousedown: VertexEvent\n            // Fired when user `mousedown` a middle marker.\n            this.fireAndForward('editable:middlemarker:mousedown', e);\n        },\n\n        onVertexMarkerDrag: function (e) {\n            this.onMove(e);\n            if (this.feature._bounds) this.extendBounds(e);\n            // 🍂namespace Editable\n            // 🍂section Vertex events\n            // 🍂event editable:vertex:drag: VertexEvent\n            // Fired when a vertex is dragged by user.\n            this.fireAndForward('editable:vertex:drag', e);\n        },\n\n        onVertexMarkerDragStart: function (e) {\n            // 🍂namespace Editable\n            // 🍂section Vertex events\n            // 🍂event editable:vertex:dragstart: VertexEvent\n            // Fired before a vertex is dragged by user.\n            this.fireAndForward('editable:vertex:dragstart', e);\n        },\n\n        onVertexMarkerDragEnd: function (e) {\n            // 🍂namespace Editable\n            // 🍂section Vertex events\n            // 🍂event editable:vertex:dragend: VertexEvent\n            // Fired after a vertex is dragged by user.\n            this.fireAndForward('editable:vertex:dragend', e);\n        },\n\n        setDrawnLatLngs: function (latlngs) {\n            this._drawnLatLngs = latlngs || this.getDefaultLatLngs();\n        },\n\n        startDrawing: function () {\n            if (!this._drawnLatLngs) this.setDrawnLatLngs();\n            L.Editable.BaseEditor.prototype.startDrawing.call(this);\n        },\n\n        startDrawingForward: function () {\n            this.startDrawing();\n        },\n\n        endDrawing: function () {\n            this.tools.detachForwardLineGuide();\n            this.tools.detachBackwardLineGuide();\n            if (this._drawnLatLngs && this._drawnLatLngs.length < this.MIN_VERTEX) this.deleteShape(this._drawnLatLngs);\n            L.Editable.BaseEditor.prototype.endDrawing.call(this);\n            delete this._drawnLatLngs;\n        },\n\n        addLatLng: function (latlng) {\n            if (this._drawing === L.Editable.FORWARD) this._drawnLatLngs.push(latlng);\n            else this._drawnLatLngs.unshift(latlng);\n            this.feature._bounds.extend(latlng);\n            this.addVertexMarker(latlng, this._drawnLatLngs);\n            this.refresh();\n        },\n\n        newPointForward: function (latlng) {\n            this.addLatLng(latlng);\n            this.tools.attachForwardLineGuide();\n            this.tools.anchorForwardLineGuide(latlng);\n        },\n\n        newPointBackward: function (latlng) {\n            this.addLatLng(latlng);\n            this.tools.anchorBackwardLineGuide(latlng);\n        },\n\n        // 🍂namespace PathEditor\n        // 🍂method push()\n        // Programmatically add a point while drawing.\n        push: function (latlng) {\n            if (!latlng) return console.error('L.Editable.PathEditor.push expect a vaild latlng as parameter');\n            if (this._drawing === L.Editable.FORWARD) this.newPointForward(latlng);\n            else this.newPointBackward(latlng);\n        },\n\n        removeLatLng: function (latlng) {\n            latlng.__vertex.delete();\n            this.refresh();\n        },\n\n        // 🍂method pop(): L.LatLng or null\n        // Programmatically remove last point (if any) while drawing.\n        pop: function () {\n            if (this._drawnLatLngs.length <= 1) return;\n            var latlng;\n            if (this._drawing === L.Editable.FORWARD) latlng = this._drawnLatLngs[this._drawnLatLngs.length - 1];\n            else latlng = this._drawnLatLngs[0];\n            this.removeLatLng(latlng);\n            if (this._drawing === L.Editable.FORWARD) this.tools.anchorForwardLineGuide(this._drawnLatLngs[this._drawnLatLngs.length - 1]);\n            else this.tools.anchorForwardLineGuide(this._drawnLatLngs[0]);\n            return latlng;\n        },\n\n        processDrawingClick: function (e) {\n            if (e.vertex && e.vertex.editor === this) return;\n            if (this._drawing === L.Editable.FORWARD) this.newPointForward(e.latlng);\n            else this.newPointBackward(e.latlng);\n            this.fireAndForward('editable:drawing:clicked', e);\n        },\n\n        onDrawingMouseMove: function (e) {\n            L.Editable.BaseEditor.prototype.onDrawingMouseMove.call(this, e);\n            if (this._drawing) {\n                this.tools.moveForwardLineGuide(e.latlng);\n                this.tools.moveBackwardLineGuide(e.latlng);\n            }\n        },\n\n        refresh: function () {\n            this.feature.redraw();\n            this.onEditing();\n        },\n\n        // 🍂namespace PathEditor\n        // 🍂method newShape(latlng?: L.LatLng)\n        // Add a new shape (Polyline, Polygon) in a multi, and setup up drawing tools to draw it;\n        // if optional `latlng` is given, start a path at this point.\n        newShape: function (latlng) {\n            var shape = this.addNewEmptyShape();\n            if (!shape) return;\n            this.setDrawnLatLngs(shape[0] || shape);  // Polygon or polyline\n            this.startDrawingForward();\n            // 🍂namespace Editable\n            // 🍂section Shape events\n            // 🍂event editable:shape:new: ShapeEvent\n            // Fired when a new shape is created in a multi (Polygon or Polyline).\n            this.fireAndForward('editable:shape:new', {shape: shape});\n            if (latlng) this.newPointForward(latlng);\n        },\n\n        deleteShape: function (shape, latlngs) {\n            var e = {shape: shape};\n            L.Editable.makeCancellable(e);\n            // 🍂namespace Editable\n            // 🍂section Shape events\n            // 🍂event editable:shape:delete: CancelableShapeEvent\n            // Fired before a new shape is deleted in a multi (Polygon or Polyline).\n            this.fireAndForward('editable:shape:delete', e);\n            if (e._cancelled) return;\n            shape = this._deleteShape(shape, latlngs);\n            if (this.ensureNotFlat) this.ensureNotFlat();  // Polygon.\n            this.feature.setLatLngs(this.getLatLngs());  // Force bounds reset.\n            this.refresh();\n            this.reset();\n            // 🍂namespace Editable\n            // 🍂section Shape events\n            // 🍂event editable:shape:deleted: ShapeEvent\n            // Fired after a new shape is deleted in a multi (Polygon or Polyline).\n            this.fireAndForward('editable:shape:deleted', {shape: shape});\n            return shape;\n        },\n\n        _deleteShape: function (shape, latlngs) {\n            latlngs = latlngs || this.getLatLngs();\n            if (!latlngs.length) return;\n            var self = this,\n                inplaceDelete = function (latlngs, shape) {\n                    // Called when deleting a flat latlngs\n                    shape = latlngs.splice(0, Number.MAX_VALUE);\n                    return shape;\n                },\n                spliceDelete = function (latlngs, shape) {\n                    // Called when removing a latlngs inside an array\n                    latlngs.splice(latlngs.indexOf(shape), 1);\n                    if (!latlngs.length) self._deleteShape(latlngs);\n                    return shape;\n                };\n            if (latlngs === shape) return inplaceDelete(latlngs, shape);\n            for (var i = 0; i < latlngs.length; i++) {\n                if (latlngs[i] === shape) return spliceDelete(latlngs, shape);\n                else if (latlngs[i].indexOf(shape) !== -1) return spliceDelete(latlngs[i], shape);\n            }\n        },\n\n        // 🍂namespace PathEditor\n        // 🍂method deleteShapeAt(latlng: L.LatLng): Array\n        // Remove a path shape at the given `latlng`.\n        deleteShapeAt: function (latlng) {\n            var shape = this.feature.shapeAt(latlng);\n            if (shape) return this.deleteShape(shape);\n        },\n\n        // 🍂method appendShape(shape: Array)\n        // Append a new shape to the Polygon or Polyline.\n        appendShape: function (shape) {\n            this.insertShape(shape);\n        },\n\n        // 🍂method prependShape(shape: Array)\n        // Prepend a new shape to the Polygon or Polyline.\n        prependShape: function (shape) {\n            this.insertShape(shape, 0);\n        },\n\n        // 🍂method insertShape(shape: Array, index: int)\n        // Insert a new shape to the Polygon or Polyline at given index (default is to append).\n        insertShape: function (shape, index) {\n            this.ensureMulti();\n            shape = this.formatShape(shape);\n            if (typeof index === 'undefined') index = this.feature._latlngs.length;\n            this.feature._latlngs.splice(index, 0, shape);\n            this.feature.redraw();\n            if (this._enabled) this.reset();\n        },\n\n        extendBounds: function (e) {\n            this.feature._bounds.extend(e.vertex.latlng);\n        },\n\n        onDragStart: function (e) {\n            this.editLayer.clearLayers();\n            L.Editable.BaseEditor.prototype.onDragStart.call(this, e);\n        },\n\n        onDragEnd: function (e) {\n            this.initVertexMarkers();\n            L.Editable.BaseEditor.prototype.onDragEnd.call(this, e);\n        }\n\n    });\n\n    // 🍂namespace Editable; 🍂class PolylineEditor; 🍂aka L.Editable.PolylineEditor\n    // 🍂inherits PathEditor\n    L.Editable.PolylineEditor = L.Editable.PathEditor.extend({\n\n        startDrawingBackward: function () {\n            this._drawing = L.Editable.BACKWARD;\n            this.startDrawing();\n        },\n\n        // 🍂method continueBackward(latlngs?: Array)\n        // Set up drawing tools to continue the line backward.\n        continueBackward: function (latlngs) {\n            if (this.drawing()) return;\n            latlngs = latlngs || this.getDefaultLatLngs();\n            this.setDrawnLatLngs(latlngs);\n            if (latlngs.length > 0) {\n                this.tools.attachBackwardLineGuide();\n                this.tools.anchorBackwardLineGuide(latlngs[0]);\n            }\n            this.startDrawingBackward();\n        },\n\n        // 🍂method continueForward(latlngs?: Array)\n        // Set up drawing tools to continue the line forward.\n        continueForward: function (latlngs) {\n            if (this.drawing()) return;\n            latlngs = latlngs || this.getDefaultLatLngs();\n            this.setDrawnLatLngs(latlngs);\n            if (latlngs.length > 0) {\n                this.tools.attachForwardLineGuide();\n                this.tools.anchorForwardLineGuide(latlngs[latlngs.length - 1]);\n            }\n            this.startDrawingForward();\n        },\n\n        getDefaultLatLngs: function (latlngs) {\n            latlngs = latlngs || this.feature._latlngs;\n            if (!latlngs.length || latlngs[0] instanceof L.LatLng) return latlngs;\n            else return this.getDefaultLatLngs(latlngs[0]);\n        },\n\n        ensureMulti: function () {\n            if (this.feature._latlngs.length && L.Polyline._flat(this.feature._latlngs)) {\n                this.feature._latlngs = [this.feature._latlngs];\n            }\n        },\n\n        addNewEmptyShape: function () {\n            if (this.feature._latlngs.length) {\n                var shape = [];\n                this.appendShape(shape);\n                return shape;\n            } else {\n                return this.feature._latlngs;\n            }\n        },\n\n        formatShape: function (shape) {\n            if (L.Polyline._flat(shape)) return shape;\n            else if (shape[0]) return this.formatShape(shape[0]);\n        },\n\n        // 🍂method splitShape(latlngs?: Array, index: int)\n        // Split the given `latlngs` shape at index `index` and integrate new shape in instance `latlngs`.\n        splitShape: function (shape, index) {\n            if (!index || index >= shape.length - 1) return;\n            this.ensureMulti();\n            var shapeIndex = this.feature._latlngs.indexOf(shape);\n            if (shapeIndex === -1) return;\n            var first = shape.slice(0, index + 1),\n                second = shape.slice(index);\n            // We deal with reference, we don't want twice the same latlng around.\n            second[0] = L.latLng(second[0].lat, second[0].lng, second[0].alt);\n            this.feature._latlngs.splice(shapeIndex, 1, first, second);\n            this.refresh();\n            this.reset();\n        }\n\n    });\n\n    // 🍂namespace Editable; 🍂class PolygonEditor; 🍂aka L.Editable.PolygonEditor\n    // 🍂inherits PathEditor\n    L.Editable.PolygonEditor = L.Editable.PathEditor.extend({\n\n        CLOSED: true,\n        MIN_VERTEX: 3,\n\n        newPointForward: function (latlng) {\n            L.Editable.PathEditor.prototype.newPointForward.call(this, latlng);\n            if (!this.tools.backwardLineGuide._latlngs.length) this.tools.anchorBackwardLineGuide(latlng);\n            if (this._drawnLatLngs.length === 2) this.tools.attachBackwardLineGuide();\n        },\n\n        addNewEmptyHole: function (latlng) {\n            this.ensureNotFlat();\n            var latlngs = this.feature.shapeAt(latlng);\n            if (!latlngs) return;\n            var holes = [];\n            latlngs.push(holes);\n            return holes;\n        },\n\n        // 🍂method newHole(latlng?: L.LatLng, index: int)\n        // Set up drawing tools for creating a new hole on the Polygon. If the `latlng` param is given, a first point is created.\n        newHole: function (latlng) {\n            var holes = this.addNewEmptyHole(latlng);\n            if (!holes) return;\n            this.setDrawnLatLngs(holes);\n            this.startDrawingForward();\n            if (latlng) this.newPointForward(latlng);\n        },\n\n        addNewEmptyShape: function () {\n            if (this.feature._latlngs.length && this.feature._latlngs[0].length) {\n                var shape = [];\n                this.appendShape(shape);\n                return shape;\n            } else {\n                return this.feature._latlngs;\n            }\n        },\n\n        ensureMulti: function () {\n            if (this.feature._latlngs.length && L.Polyline._flat(this.feature._latlngs[0])) {\n                this.feature._latlngs = [this.feature._latlngs];\n            }\n        },\n\n        ensureNotFlat: function () {\n            if (!this.feature._latlngs.length || L.Polyline._flat(this.feature._latlngs)) this.feature._latlngs = [this.feature._latlngs];\n        },\n\n        vertexCanBeDeleted: function (vertex) {\n            var parent = this.feature.parentShape(vertex.latlngs),\n                idx = L.Util.indexOf(parent, vertex.latlngs);\n            if (idx > 0) return true;  // Holes can be totally deleted without removing the layer itself.\n            return L.Editable.PathEditor.prototype.vertexCanBeDeleted.call(this, vertex);\n        },\n\n        getDefaultLatLngs: function () {\n            if (!this.feature._latlngs.length) this.feature._latlngs.push([]);\n            return this.feature._latlngs[0];\n        },\n\n        formatShape: function (shape) {\n            // [[1, 2], [3, 4]] => must be nested\n            // [] => must be nested\n            // [[]] => is already nested\n            if (L.Polyline._flat(shape) && (!shape[0] || shape[0].length !== 0)) return [shape];\n            else return shape;\n        }\n\n    });\n\n    // 🍂namespace Editable; 🍂class RectangleEditor; 🍂aka L.Editable.RectangleEditor\n    // 🍂inherits PathEditor\n    L.Editable.RectangleEditor = L.Editable.PathEditor.extend({\n\n        CLOSED: true,\n        MIN_VERTEX: 4,\n\n        options: {\n            skipMiddleMarkers: true\n        },\n\n        extendBounds: function (e) {\n            var index = e.vertex.getIndex(),\n                next = e.vertex.getNext(),\n                previous = e.vertex.getPrevious(),\n                oppositeIndex = (index + 2) % 4,\n                opposite = e.vertex.latlngs[oppositeIndex],\n                bounds = new L.LatLngBounds(e.latlng, opposite);\n            // Update latlngs by hand to preserve order.\n            previous.latlng.update([e.latlng.lat, opposite.lng]);\n            next.latlng.update([opposite.lat, e.latlng.lng]);\n            this.updateBounds(bounds);\n            this.refreshVertexMarkers();\n        },\n\n        onDrawingMouseDown: function (e) {\n            L.Editable.PathEditor.prototype.onDrawingMouseDown.call(this, e);\n            this.connect();\n            var latlngs = this.getDefaultLatLngs();\n            // L.Polygon._convertLatLngs removes last latlng if it equals first point,\n            // which is the case here as all latlngs are [0, 0]\n            if (latlngs.length === 3) latlngs.push(e.latlng);\n            var bounds = new L.LatLngBounds(e.latlng, e.latlng);\n            this.updateBounds(bounds);\n            this.updateLatLngs(bounds);\n            this.refresh();\n            this.reset();\n            // Stop dragging map.\n            // L.Draggable has two workflows:\n            // - mousedown => mousemove => mouseup\n            // - touchstart => touchmove => touchend\n            // Problem: L.Map.Tap does not allow us to listen to touchstart, so we only\n            // can deal with mousedown, but then when in a touch device, we are dealing with\n            // simulated events (actually simulated by L.Map.Tap), which are no more taken\n            // into account by L.Draggable.\n            // Ref.: https://github.com/Leaflet/Leaflet.Editable/issues/103\n            e.originalEvent._simulated = false;\n            this.map.dragging._draggable._onUp(e.originalEvent);\n            // Now transfer ongoing drag action to the bottom right corner.\n            // Should we refine which corne will handle the drag according to\n            // drag direction?\n            latlngs[3].__vertex.dragging._draggable._onDown(e.originalEvent);\n        },\n\n        onDrawingMouseUp: function (e) {\n            this.commitDrawing(e);\n            e.originalEvent._simulated = false;\n            L.Editable.PathEditor.prototype.onDrawingMouseUp.call(this, e);\n        },\n\n        onDrawingMouseMove: function (e) {\n            e.originalEvent._simulated = false;\n            L.Editable.PathEditor.prototype.onDrawingMouseMove.call(this, e);\n        },\n\n\n        getDefaultLatLngs: function (latlngs) {\n            return latlngs || this.feature._latlngs[0];\n        },\n\n        updateBounds: function (bounds) {\n            this.feature._bounds = bounds;\n        },\n\n        updateLatLngs: function (bounds) {\n            var latlngs = this.getDefaultLatLngs(),\n                newLatlngs = this.feature._boundsToLatLngs(bounds);\n            // Keep references.\n            for (var i = 0; i < latlngs.length; i++) {\n                latlngs[i].update(newLatlngs[i]);\n            };\n        }\n\n    });\n\n    // 🍂namespace Editable; 🍂class CircleEditor; 🍂aka L.Editable.CircleEditor\n    // 🍂inherits PathEditor\n    L.Editable.CircleEditor = L.Editable.PathEditor.extend({\n\n        MIN_VERTEX: 2,\n\n        options: {\n            skipMiddleMarkers: true\n        },\n\n        initialize: function (map, feature, options) {\n            L.Editable.PathEditor.prototype.initialize.call(this, map, feature, options);\n            this._resizeLatLng = this.computeResizeLatLng();\n        },\n\n        computeResizeLatLng: function () {\n            // While circle is not added to the map, _radius is not set.\n            var delta = (this.feature._radius || this.feature._mRadius) * Math.cos(Math.PI / 4),\n                point = this.map.project(this.feature._latlng);\n            return this.map.unproject([point.x + delta, point.y - delta]);\n        },\n\n        updateResizeLatLng: function () {\n            this._resizeLatLng.update(this.computeResizeLatLng());\n            this._resizeLatLng.__vertex.update();\n        },\n\n        getLatLngs: function () {\n            return [this.feature._latlng, this._resizeLatLng];\n        },\n\n        getDefaultLatLngs: function () {\n            return this.getLatLngs();\n        },\n\n        onVertexMarkerDrag: function (e) {\n            if (e.vertex.getIndex() === 1) this.resize(e);\n            else this.updateResizeLatLng(e);\n            L.Editable.PathEditor.prototype.onVertexMarkerDrag.call(this, e);\n        },\n\n        resize: function (e) {\n            var radius = this.feature._latlng.distanceTo(e.latlng)\n            this.feature.setRadius(radius);\n        },\n\n        onDrawingMouseDown: function (e) {\n            L.Editable.PathEditor.prototype.onDrawingMouseDown.call(this, e);\n            this._resizeLatLng.update(e.latlng);\n            this.feature._latlng.update(e.latlng);\n            this.connect();\n            // Stop dragging map.\n            e.originalEvent._simulated = false;\n            this.map.dragging._draggable._onUp(e.originalEvent);\n            // Now transfer ongoing drag action to the radius handler.\n            this._resizeLatLng.__vertex.dragging._draggable._onDown(e.originalEvent);\n        },\n\n        onDrawingMouseUp: function (e) {\n            this.commitDrawing(e);\n            e.originalEvent._simulated = false;\n            L.Editable.PathEditor.prototype.onDrawingMouseUp.call(this, e);\n        },\n\n        onDrawingMouseMove: function (e) {\n            e.originalEvent._simulated = false;\n            L.Editable.PathEditor.prototype.onDrawingMouseMove.call(this, e);\n        },\n\n        onDrag: function (e) {\n            L.Editable.PathEditor.prototype.onDrag.call(this, e);\n            this.feature.dragging.updateLatLng(this._resizeLatLng);\n        }\n\n    });\n\n    // 🍂namespace Editable; 🍂class EditableMixin\n    // `EditableMixin` is included to `L.Polyline`, `L.Polygon`, `L.Rectangle`, `L.Circle`\n    // and `L.Marker`. It adds some methods to them.\n    // *When editing is enabled, the editor is accessible on the instance with the\n    // `editor` property.*\n    var EditableMixin = {\n\n        createEditor: function (map) {\n            map = map || this._map;\n            var tools = (this.options.editOptions || {}).editTools || map.editTools;\n            if (!tools) throw Error('Unable to detect Editable instance.')\n            var Klass = this.options.editorClass || this.getEditorClass(tools);\n            return new Klass(map, this, this.options.editOptions);\n        },\n\n        // 🍂method enableEdit(map?: L.Map): this.editor\n        // Enable editing, by creating an editor if not existing, and then calling `enable` on it.\n        enableEdit: function (map) {\n            if (!this.editor) this.createEditor(map);\n            this.editor.enable();\n            return this.editor;\n        },\n\n        // 🍂method editEnabled(): boolean\n        // Return true if current instance has an editor attached, and this editor is enabled.\n        editEnabled: function () {\n            return this.editor && this.editor.enabled();\n        },\n\n        // 🍂method disableEdit()\n        // Disable editing, also remove the editor property reference.\n        disableEdit: function () {\n            if (this.editor) {\n                this.editor.disable();\n                delete this.editor;\n            }\n        },\n\n        // 🍂method toggleEdit()\n        // Enable or disable editing, according to current status.\n        toggleEdit: function () {\n            if (this.editEnabled()) this.disableEdit();\n            else this.enableEdit();\n        },\n\n        _onEditableAdd: function () {\n            if (this.editor) this.enableEdit();\n        }\n\n    };\n\n    var PolylineMixin = {\n\n        getEditorClass: function (tools) {\n            return (tools && tools.options.polylineEditorClass) ? tools.options.polylineEditorClass : L.Editable.PolylineEditor;\n        },\n\n        shapeAt: function (latlng, latlngs) {\n            // We can have those cases:\n            // - latlngs are just a flat array of latlngs, use this\n            // - latlngs is an array of arrays of latlngs, loop over\n            var shape = null;\n            latlngs = latlngs || this._latlngs;\n            if (!latlngs.length) return shape;\n            else if (L.Polyline._flat(latlngs) && this.isInLatLngs(latlng, latlngs)) shape = latlngs;\n            else for (var i = 0; i < latlngs.length; i++) if (this.isInLatLngs(latlng, latlngs[i])) return latlngs[i];\n            return shape;\n        },\n\n        isInLatLngs: function (l, latlngs) {\n            if (!latlngs) return false;\n            var i, k, len, part = [], p,\n                w = this._clickTolerance();\n            this._projectLatlngs(latlngs, part, this._pxBounds);\n            part = part[0];\n            p = this._map.latLngToLayerPoint(l);\n\n            if (!this._pxBounds.contains(p)) { return false; }\n            for (i = 1, len = part.length, k = 0; i < len; k = i++) {\n\n                if (L.LineUtil.pointToSegmentDistance(p, part[k], part[i]) <= w) {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n    };\n\n    var PolygonMixin = {\n\n        getEditorClass: function (tools) {\n            return (tools && tools.options.polygonEditorClass) ? tools.options.polygonEditorClass : L.Editable.PolygonEditor;\n        },\n\n        shapeAt: function (latlng, latlngs) {\n            // We can have those cases:\n            // - latlngs are just a flat array of latlngs, use this\n            // - latlngs is an array of arrays of latlngs, this is a simple polygon (maybe with holes), use the first\n            // - latlngs is an array of arrays of arrays, this is a multi, loop over\n            var shape = null;\n            latlngs = latlngs || this._latlngs;\n            if (!latlngs.length) return shape;\n            else if (L.Polyline._flat(latlngs) && this.isInLatLngs(latlng, latlngs)) shape = latlngs;\n            else if (L.Polyline._flat(latlngs[0]) && this.isInLatLngs(latlng, latlngs[0])) shape = latlngs;\n            else for (var i = 0; i < latlngs.length; i++) if (this.isInLatLngs(latlng, latlngs[i][0])) return latlngs[i];\n            return shape;\n        },\n\n        isInLatLngs: function (l, latlngs) {\n            var inside = false, l1, l2, j, k, len2;\n\n            for (j = 0, len2 = latlngs.length, k = len2 - 1; j < len2; k = j++) {\n                l1 = latlngs[j];\n                l2 = latlngs[k];\n\n                if (((l1.lat > l.lat) !== (l2.lat > l.lat)) &&\n                        (l.lng < (l2.lng - l1.lng) * (l.lat - l1.lat) / (l2.lat - l1.lat) + l1.lng)) {\n                    inside = !inside;\n                }\n            }\n\n            return inside;\n        },\n\n        parentShape: function (shape, latlngs) {\n            latlngs = latlngs || this._latlngs;\n            if (!latlngs) return;\n            var idx = L.Util.indexOf(latlngs, shape);\n            if (idx !== -1) return latlngs;\n            for (var i = 0; i < latlngs.length; i++) {\n                idx = L.Util.indexOf(latlngs[i], shape);\n                if (idx !== -1) return latlngs[i];\n            }\n        }\n\n    };\n\n\n    var MarkerMixin = {\n\n        getEditorClass: function (tools) {\n            return (tools && tools.options.markerEditorClass) ? tools.options.markerEditorClass : L.Editable.MarkerEditor;\n        }\n\n    };\n\n    var RectangleMixin = {\n\n        getEditorClass: function (tools) {\n            return (tools && tools.options.rectangleEditorClass) ? tools.options.rectangleEditorClass : L.Editable.RectangleEditor;\n        }\n\n    };\n\n    var CircleMixin = {\n\n        getEditorClass: function (tools) {\n            return (tools && tools.options.circleEditorClass) ? tools.options.circleEditorClass : L.Editable.CircleEditor;\n        }\n\n    };\n\n    var keepEditable = function () {\n        // Make sure you can remove/readd an editable layer.\n        this.on('add', this._onEditableAdd);\n    };\n\n\n\n    if (L.Polyline) {\n        L.Polyline.include(EditableMixin);\n        L.Polyline.include(PolylineMixin);\n        L.Polyline.addInitHook(keepEditable);\n    }\n    if (L.Polygon) {\n        L.Polygon.include(EditableMixin);\n        L.Polygon.include(PolygonMixin);\n    }\n    if (L.Marker) {\n        L.Marker.include(EditableMixin);\n        L.Marker.include(MarkerMixin);\n        L.Marker.addInitHook(keepEditable);\n    }\n    if (L.Rectangle) {\n        L.Rectangle.include(EditableMixin);\n        L.Rectangle.include(RectangleMixin);\n    }\n    if (L.Circle) {\n        L.Circle.include(EditableMixin);\n        L.Circle.include(CircleMixin);\n    }\n\n    L.LatLng.prototype.update = function (latlng) {\n        latlng = L.latLng(latlng);\n        this.lat = latlng.lat;\n        this.lng = latlng.lng;\n    }\n\n}, window));\n\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/* A Draggable that does not update the element position\nand takes care of only bubbling to targetted path in Canvas mode. */\nL.PathDraggable = L.Draggable.extend({\n\n  initialize: function (path) {\n    this._path = path;\n    this._canvas = (path._map.getRenderer(path) instanceof L.Canvas);\n    var element = this._canvas ? this._path._map.getRenderer(this._path)._container : this._path._path;\n    L.Draggable.prototype.initialize.call(this, element, element, true);\n  },\n\n  _updatePosition: function () {\n    var e = {originalEvent: this._lastEvent};\n    this.fire('drag', e);\n  },\n\n  _onDown: function (e) {\n    var first = e.touches ? e.touches[0] : e;\n    this._startPoint = new L.Point(first.clientX, first.clientY);\n    if (this._canvas && !this._path._containsPoint(this._path._map.mouseEventToLayerPoint(first))) { return; }\n    L.Draggable.prototype._onDown.call(this, e);\n  }\n\n});\n\n\nL.Handler.PathDrag = L.Handler.extend({\n\n  initialize: function (path) {\n    this._path = path;\n  },\n\n  getEvents: function () {\n    return {\n      dragstart: this._onDragStart,\n      drag: this._onDrag,\n      dragend: this._onDragEnd\n    };\n  },\n\n  addHooks: function () {\n    if (!this._draggable) { this._draggable = new L.PathDraggable(this._path); }\n    this._draggable.on(this.getEvents(), this).enable();\n    L.DomUtil.addClass(this._draggable._element, 'leaflet-path-draggable');\n  },\n\n  removeHooks: function () {\n    this._draggable.off(this.getEvents(), this).disable();\n    L.DomUtil.removeClass(this._draggable._element, 'leaflet-path-draggable');\n  },\n\n  moved: function () {\n    return this._draggable && this._draggable._moved;\n  },\n\n  _onDragStart: function () {\n    this._startPoint = this._draggable._startPoint;\n    this._path\n        .closePopup()\n        .fire('movestart')\n        .fire('dragstart');\n  },\n\n  _onDrag: function (e) {\n    var path = this._path,\n        event = (e.originalEvent.touches && e.originalEvent.touches.length === 1 ? e.originalEvent.touches[0] : e.originalEvent),\n        newPoint = L.point(event.clientX, event.clientY),\n        latlng = path._map.layerPointToLatLng(newPoint);\n\n    this._offset = newPoint.subtract(this._startPoint);\n    this._startPoint = newPoint;\n\n    this._path.eachLatLng(this.updateLatLng, this);\n    path.redraw();\n\n    e.latlng = latlng;\n    e.offset = this._offset;\n    path.fire('move', e)\n        .fire('drag', e);\n  },\n\n  _onDragEnd: function (e) {\n    if (this._path._bounds) this.resetBounds();\n    this._path.fire('moveend')\n        .fire('dragend', e);\n  },\n\n  latLngToLayerPoint: function (latlng) {\n    // Same as map.latLngToLayerPoint, but without the round().\n    var projectedPoint = this._path._map.project(L.latLng(latlng));\n    return projectedPoint._subtract(this._path._map.getPixelOrigin());\n  },\n\n  updateLatLng: function (latlng) {\n    var oldPoint = this.latLngToLayerPoint(latlng);\n    oldPoint._add(this._offset);\n    var newLatLng = this._path._map.layerPointToLatLng(oldPoint);\n    latlng.lat = newLatLng.lat;\n    latlng.lng = newLatLng.lng;\n  },\n\n  resetBounds: function () {\n    this._path._bounds = new L.LatLngBounds();\n    this._path.eachLatLng(function (latlng) {\n      this._bounds.extend(latlng);\n    });\n  }\n\n});\n\nL.Path.include({\n\n  eachLatLng: function (callback, context) {\n    context = context || this;\n    var loop = function (latlngs) {\n      for (var i = 0; i < latlngs.length; i++) {\n        if (L.Util.isArray(latlngs[i])) loop(latlngs[i]);\n        else callback.call(context, latlngs[i]);\n      }\n    };\n    loop(this.getLatLngs ? this.getLatLngs() : [this.getLatLng()]);\n  }\n\n});\n\nL.Path.addInitHook(function () {\n\n  this.dragging = new L.Handler.PathDrag(this);\n  if (this.options.draggable) {\n    this.once('add', function () {\n      this.dragging.enable();\n    });\n  }\n\n});\n\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__(1);\n\n\n/***/ })\n/******/ ]);\n});\n\n\n// WEBPACK FOOTER //\n// Limapper.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 4);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 3a511d801cf3baa101e0","module.exports = __WEBPACK_EXTERNAL_MODULE_0__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"L\"\n// module id = 0\n// module chunks = 0","import L from 'leaflet';\nrequire('leaflet.path.drag');\nrequire('leaflet-editable');\n\n/**\n * Leaflet Image Mapper\n */\nexport default class Limapper {\n  /**\n   * initialize object\n   * @return {object} Instance\n   */\n  constructor() {\n    this._name = 'Limapper';\n    this._latestItem = null;\n    this._selectedItem = null;\n    this._identity = 1;\n  }\n\n  /**\n   * get name\n   * @return {string} name\n   */\n  get name() {\n    return this._name;\n  }\n\n  /**\n   * get item mapped data\n   * @param  {object} item\n   * @return {object}      item or null if no data found\n   */\n  getMapData(item) {\n    let self = this;\n    let v = item;\n\n    if (!self._map) {\n      return null;\n    }\n\n    let map = self._map;\n    let po = map.latLngToLayerPoint(new L.LatLng(0, 0));\n\n    // handle rectangle\n    if (v.editor instanceof L.Editable.RectangleEditor) {\n      if (v._bounds) {\n        if (!v.mapdata) {\n          v.mapdata = {rect: {}};\n        }\n        let nw = map.latLngToLayerPoint(v._bounds.getNorthWest());\n        let se = map.latLngToLayerPoint(v._bounds.getSouthEast());\n\n        v.mapdata.rect.x1 = nw.x - po.x;\n        v.mapdata.rect.x2 = se.x - po.x;\n        v.mapdata.rect.y1 = nw.y - po.y;\n        v.mapdata.rect.y2 = se.y - po.y;\n        return v;\n      }\n    }\n    return null;\n  }\n\n  /**\n   * initialize object\n   * @param  {object} opts options\n   * @return {object}      self\n   */\n  init(opts) {\n    let self = this;\n    let defs = {\n      minZoom: 1,\n      maxZoom: 5,\n      center: [0, 0],\n      zoom: 1,\n      editable: true,\n      crs: L.CRS.Simple\n    };\n    let southWest, northEast, bounds, map, layerPopup;\n\n    // apply defaults\n    for (let k in defs) {\n      opts[k] = opts[k] || defs[k];\n    }\n    map = L.map(opts.elid || 'map', opts);\n    southWest = map.unproject([0, opts.imageHeight]);\n    northEast = map.unproject([opts.imageWidth, 0]);\n    bounds = new L.LatLngBounds(southWest, northEast);\n    L.imageOverlay(opts.imageUrl, bounds).addTo(map);\n    map.setMaxBounds(bounds);\n    this._map = map;\n\n    // add new edit control with behavior\n    L.EditControl = L.Control.extend({\n      options: {\n        position: 'topleft',\n        callback: null,\n        kind: '',\n        html: ''\n      },\n      onAdd: function (map) {\n        let container = L.DomUtil.create('div', 'leaflet-control leaflet-bar'),\n          link = L.DomUtil.create('a', '', container);\n\n        link.href = '#';\n        link.title = 'Create a new ' + this.options.kind;\n        link.innerHTML = this.options.html;\n        L.DomEvent\n          .on(link, 'click', L.DomEvent.stop)\n          .on(link, 'click', function () {\n            window.LAYER = this.options.callback.call(map.editTools);\n          }, this);\n\n        return container;\n      }\n    });\n\n    // now create the rectangle control\n    L.NewRectangleControl = L.EditControl.extend({\n      options: {\n        position: 'topleft',\n        callback: map.editTools.startRectangle,\n        kind: 'rect',\n        html: '⬛'\n      }\n    });\n\n    // add the control to map\n    map.addControl(new L.NewRectangleControl());\n\n    // handle new item\n    map.on('layeradd', (e) => {\n      if (e.layer instanceof L.Path) {\n        let item = e.layer;\n\n        self._latestItem = item;\n        item.mapdata = {name: `Item #${self._identity++}` };\n        item.on('dblclick', L.DomEvent.stop).on('dblclick', item.toggleEdit);\n        item.on('mouseover', (e) => {\n          if (map && item.mapdata) {\n            layerPopup = L.popup()\n            .setLatLng(e.latlng)\n            .setContent(item.mapdata.name)\n            .openOn(map);\n          }\n        });\n\n        item.on('mouseout', (e) => {\n          if (layerPopup && map) {\n            map.closePopup(layerPopup);\n            layerPopup = null;\n          }\n        });\n      }\n    });\n\n    return self;\n  }\n\n  /**\n   * get items\n   * @return {Array} list of items\n   */\n  get items() {\n    let self = this;\n    let items = [];\n\n    if (!self._map) {\n      return items;\n    }\n\n    self._map.eachLayer((v, k) => {\n      if (self.getData(v)) {\n        items.push(v);\n      }\n    });\n\n    return items;\n  }\n\n  /**\n   * get last item added\n   * @return {object} last item added\n   */\n  get latestItem() {\n    return this.getMapData(this._latestItem);\n  }\n\n  p2ll(x, y) {\n    return this._map.containerPointToLatLng([x, y]);\n  }\n\n  /**\n   * add a single pixel coordinates item\n   * @param {object} mapData item map data\n   */\n  addItem(mapData) {\n    let self = this;\n    let rect = mapData.rect;\n\n    var layer = L.rectangle(\n      [self.p2ll(rect.x1, rect.y1), self.p2ll(rect.x2, rect.y2)]\n    ).addTo(self._map);\n\n    layer.enableEdit();\n    return layer;\n  }\n\n  addItems(items) {\n    let self = this;\n    let rst = [];\n\n    items.forEach(i => {\n      let it = self.addItem(i);\n\n      rst.push(it);\n    });\n\n    return it;\n  }\n\n  /**\n   * remove item\n   * @param {object} item the map data item\n   */\n  removeItem(item) {\n    if (item && item.remove) {\n      item.remove();\n    }\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.js","'use strict';\n(function (factory, window) {\n    /*globals define, module, require*/\n\n    // define an AMD module that relies on 'leaflet'\n    if (typeof define === 'function' && define.amd) {\n        define(['leaflet'], factory);\n\n\n    // define a Common JS module that relies on 'leaflet'\n    } else if (typeof exports === 'object') {\n        module.exports = factory(require('leaflet'));\n    }\n\n    // attach your plugin to the global 'L' variable\n    if(typeof window !== 'undefined' && window.L){\n        factory(window.L);\n    }\n\n}(function (L) {\n    // 🍂miniclass CancelableEvent (Event objects)\n    // 🍂method cancel()\n    // Cancel any subsequent action.\n\n    // 🍂miniclass VertexEvent (Event objects)\n    // 🍂property vertex: VertexMarker\n    // The vertex that fires the event.\n\n    // 🍂miniclass ShapeEvent (Event objects)\n    // 🍂property shape: Array\n    // The shape (LatLngs array) subject of the action.\n\n    // 🍂miniclass CancelableVertexEvent (Event objects)\n    // 🍂inherits VertexEvent\n    // 🍂inherits CancelableEvent\n\n    // 🍂miniclass CancelableShapeEvent (Event objects)\n    // 🍂inherits ShapeEvent\n    // 🍂inherits CancelableEvent\n\n    // 🍂miniclass LayerEvent (Event objects)\n    // 🍂property layer: object\n    // The Layer (Marker, Polyline…) subject of the action.\n\n    // 🍂namespace Editable; 🍂class Editable; 🍂aka L.Editable\n    // Main edition handler. By default, it is attached to the map\n    // as `map.editTools` property.\n    // Leaflet.Editable is made to be fully extendable. You have three ways to customize\n    // the behaviour: using options, listening to events, or extending.\n    L.Editable = L.Evented.extend({\n\n        statics: {\n            FORWARD: 1,\n            BACKWARD: -1\n        },\n\n        options: {\n\n            // You can pass them when creating a map using the `editOptions` key.\n            // 🍂option zIndex: int = 1000\n            // The default zIndex of the editing tools.\n            zIndex: 1000,\n\n            // 🍂option polygonClass: class = L.Polygon\n            // Class to be used when creating a new Polygon.\n            polygonClass: L.Polygon,\n\n            // 🍂option polylineClass: class = L.Polyline\n            // Class to be used when creating a new Polyline.\n            polylineClass: L.Polyline,\n\n            // 🍂option markerClass: class = L.Marker\n            // Class to be used when creating a new Marker.\n            markerClass: L.Marker,\n\n            // 🍂option rectangleClass: class = L.Rectangle\n            // Class to be used when creating a new Rectangle.\n            rectangleClass: L.Rectangle,\n\n            // 🍂option circleClass: class = L.Circle\n            // Class to be used when creating a new Circle.\n            circleClass: L.Circle,\n\n            // 🍂option drawingCSSClass: string = 'leaflet-editable-drawing'\n            // CSS class to be added to the map container while drawing.\n            drawingCSSClass: 'leaflet-editable-drawing',\n\n            // 🍂option drawingCursor: const = 'crosshair'\n            // Cursor mode set to the map while drawing.\n            drawingCursor: 'crosshair',\n\n            // 🍂option editLayer: Layer = new L.LayerGroup()\n            // Layer used to store edit tools (vertex, line guide…).\n            editLayer: undefined,\n\n            // 🍂option featuresLayer: Layer = new L.LayerGroup()\n            // Default layer used to store drawn features (Marker, Polyline…).\n            featuresLayer: undefined,\n\n            // 🍂option polylineEditorClass: class = PolylineEditor\n            // Class to be used as Polyline editor.\n            polylineEditorClass: undefined,\n\n            // 🍂option polygonEditorClass: class = PolygonEditor\n            // Class to be used as Polygon editor.\n            polygonEditorClass: undefined,\n\n            // 🍂option markerEditorClass: class = MarkerEditor\n            // Class to be used as Marker editor.\n            markerEditorClass: undefined,\n\n            // 🍂option rectangleEditorClass: class = RectangleEditor\n            // Class to be used as Rectangle editor.\n            rectangleEditorClass: undefined,\n\n            // 🍂option circleEditorClass: class = CircleEditor\n            // Class to be used as Circle editor.\n            circleEditorClass: undefined,\n\n            // 🍂option lineGuideOptions: hash = {}\n            // Options to be passed to the line guides.\n            lineGuideOptions: {},\n\n            // 🍂option skipMiddleMarkers: boolean = false\n            // Set this to true if you don't want middle markers.\n            skipMiddleMarkers: false\n\n        },\n\n        initialize: function (map, options) {\n            L.setOptions(this, options);\n            this._lastZIndex = this.options.zIndex;\n            this.map = map;\n            this.editLayer = this.createEditLayer();\n            this.featuresLayer = this.createFeaturesLayer();\n            this.forwardLineGuide = this.createLineGuide();\n            this.backwardLineGuide = this.createLineGuide();\n        },\n\n        fireAndForward: function (type, e) {\n            e = e || {};\n            e.editTools = this;\n            this.fire(type, e);\n            this.map.fire(type, e);\n        },\n\n        createLineGuide: function () {\n            var options = L.extend({dashArray: '5,10', weight: 1, interactive: false}, this.options.lineGuideOptions);\n            return L.polyline([], options);\n        },\n\n        createVertexIcon: function (options) {\n            return L.Browser.touch ? new L.Editable.TouchVertexIcon(options) : new L.Editable.VertexIcon(options);\n        },\n\n        createEditLayer: function () {\n            return this.options.editLayer || new L.LayerGroup().addTo(this.map);\n        },\n\n        createFeaturesLayer: function () {\n            return this.options.featuresLayer || new L.LayerGroup().addTo(this.map);\n        },\n\n        moveForwardLineGuide: function (latlng) {\n            if (this.forwardLineGuide._latlngs.length) {\n                this.forwardLineGuide._latlngs[1] = latlng;\n                this.forwardLineGuide._bounds.extend(latlng);\n                this.forwardLineGuide.redraw();\n            }\n        },\n\n        moveBackwardLineGuide: function (latlng) {\n            if (this.backwardLineGuide._latlngs.length) {\n                this.backwardLineGuide._latlngs[1] = latlng;\n                this.backwardLineGuide._bounds.extend(latlng);\n                this.backwardLineGuide.redraw();\n            }\n        },\n\n        anchorForwardLineGuide: function (latlng) {\n            this.forwardLineGuide._latlngs[0] = latlng;\n            this.forwardLineGuide._bounds.extend(latlng);\n            this.forwardLineGuide.redraw();\n        },\n\n        anchorBackwardLineGuide: function (latlng) {\n            this.backwardLineGuide._latlngs[0] = latlng;\n            this.backwardLineGuide._bounds.extend(latlng);\n            this.backwardLineGuide.redraw();\n        },\n\n        attachForwardLineGuide: function () {\n            this.editLayer.addLayer(this.forwardLineGuide);\n        },\n\n        attachBackwardLineGuide: function () {\n            this.editLayer.addLayer(this.backwardLineGuide);\n        },\n\n        detachForwardLineGuide: function () {\n            this.forwardLineGuide.setLatLngs([]);\n            this.editLayer.removeLayer(this.forwardLineGuide);\n        },\n\n        detachBackwardLineGuide: function () {\n            this.backwardLineGuide.setLatLngs([]);\n            this.editLayer.removeLayer(this.backwardLineGuide);\n        },\n\n        blockEvents: function () {\n            // Hack: force map not to listen to other layers events while drawing.\n            if (!this._oldTargets) {\n                this._oldTargets = this.map._targets;\n                this.map._targets = {};\n            }\n        },\n\n        unblockEvents: function () {\n            if (this._oldTargets) {\n                // Reset, but keep targets created while drawing.\n                this.map._targets = L.extend(this.map._targets, this._oldTargets);\n                delete this._oldTargets;\n            }\n        },\n\n        registerForDrawing: function (editor) {\n            if (this._drawingEditor) this.unregisterForDrawing(this._drawingEditor);\n            this.blockEvents();\n            editor.reset();  // Make sure editor tools still receive events.\n            this._drawingEditor = editor;\n            this.map.on('mousemove touchmove', editor.onDrawingMouseMove, editor);\n            this.map.on('mousedown', this.onMousedown, this);\n            this.map.on('mouseup', this.onMouseup, this);\n            L.DomUtil.addClass(this.map._container, this.options.drawingCSSClass);\n            this.defaultMapCursor = this.map._container.style.cursor;\n            this.map._container.style.cursor = this.options.drawingCursor;\n        },\n\n        unregisterForDrawing: function (editor) {\n            this.unblockEvents();\n            L.DomUtil.removeClass(this.map._container, this.options.drawingCSSClass);\n            this.map._container.style.cursor = this.defaultMapCursor;\n            editor = editor || this._drawingEditor;\n            if (!editor) return;\n            this.map.off('mousemove touchmove', editor.onDrawingMouseMove, editor);\n            this.map.off('mousedown', this.onMousedown, this);\n            this.map.off('mouseup', this.onMouseup, this);\n            if (editor !== this._drawingEditor) return;\n            delete this._drawingEditor;\n            if (editor._drawing) editor.cancelDrawing();\n        },\n\n        onMousedown: function (e) {\n            this._mouseDown = e;\n            this._drawingEditor.onDrawingMouseDown(e);\n        },\n\n        onMouseup: function (e) {\n            if (this._mouseDown) {\n                var editor = this._drawingEditor,\n                    mouseDown = this._mouseDown;\n                this._mouseDown = null;\n                editor.onDrawingMouseUp(e);\n                if (this._drawingEditor !== editor) return;  // onDrawingMouseUp may call unregisterFromDrawing.\n                var origin = L.point(mouseDown.originalEvent.clientX, mouseDown.originalEvent.clientY);\n                var distance = L.point(e.originalEvent.clientX, e.originalEvent.clientY).distanceTo(origin);\n                if (Math.abs(distance) < 9 * (window.devicePixelRatio || 1)) this._drawingEditor.onDrawingClick(e);\n            }\n        },\n\n        // 🍂section Public methods\n        // You will generally access them by the `map.editTools`\n        // instance:\n        //\n        // `map.editTools.startPolyline();`\n\n        // 🍂method drawing(): boolean\n        // Return true if any drawing action is ongoing.\n        drawing: function () {\n            return this._drawingEditor && this._drawingEditor.drawing();\n        },\n\n        // 🍂method stopDrawing()\n        // When you need to stop any ongoing drawing, without needing to know which editor is active.\n        stopDrawing: function () {\n            this.unregisterForDrawing();\n        },\n\n        // 🍂method commitDrawing()\n        // When you need to commit any ongoing drawing, without needing to know which editor is active.\n        commitDrawing: function (e) {\n            if (!this._drawingEditor) return;\n            this._drawingEditor.commitDrawing(e);\n        },\n\n        connectCreatedToMap: function (layer) {\n            return this.featuresLayer.addLayer(layer);\n        },\n\n        // 🍂method startPolyline(latlng: L.LatLng, options: hash): L.Polyline\n        // Start drawing a Polyline. If `latlng` is given, a first point will be added. In any case, continuing on user click.\n        // If `options` is given, it will be passed to the Polyline class constructor.\n        startPolyline: function (latlng, options) {\n            var line = this.createPolyline([], options);\n            line.enableEdit(this.map).newShape(latlng);\n            return line;\n        },\n\n        // 🍂method startPolygon(latlng: L.LatLng, options: hash): L.Polygon\n        // Start drawing a Polygon. If `latlng` is given, a first point will be added. In any case, continuing on user click.\n        // If `options` is given, it will be passed to the Polygon class constructor.\n        startPolygon: function (latlng, options) {\n            var polygon = this.createPolygon([], options);\n            polygon.enableEdit(this.map).newShape(latlng);\n            return polygon;\n        },\n\n        // 🍂method startMarker(latlng: L.LatLng, options: hash): L.Marker\n        // Start adding a Marker. If `latlng` is given, the Marker will be shown first at this point.\n        // In any case, it will follow the user mouse, and will have a final `latlng` on next click (or touch).\n        // If `options` is given, it will be passed to the Marker class constructor.\n        startMarker: function (latlng, options) {\n            latlng = latlng || this.map.getCenter().clone();\n            var marker = this.createMarker(latlng, options);\n            marker.enableEdit(this.map).startDrawing();\n            return marker;\n        },\n\n        // 🍂method startRectangle(latlng: L.LatLng, options: hash): L.Rectangle\n        // Start drawing a Rectangle. If `latlng` is given, the Rectangle anchor will be added. In any case, continuing on user drag.\n        // If `options` is given, it will be passed to the Rectangle class constructor.\n        startRectangle: function(latlng, options) {\n            var corner = latlng || L.latLng([0, 0]);\n            var bounds = new L.LatLngBounds(corner, corner);\n            var rectangle = this.createRectangle(bounds, options);\n            rectangle.enableEdit(this.map).startDrawing();\n            return rectangle;\n        },\n\n        // 🍂method startCircle(latlng: L.LatLng, options: hash): L.Circle\n        // Start drawing a Circle. If `latlng` is given, the Circle anchor will be added. In any case, continuing on user drag.\n        // If `options` is given, it will be passed to the Circle class constructor.\n        startCircle: function (latlng, options) {\n            latlng = latlng || this.map.getCenter().clone();\n            var circle = this.createCircle(latlng, options);\n            circle.enableEdit(this.map).startDrawing();\n            return circle;\n        },\n\n        startHole: function (editor, latlng) {\n            editor.newHole(latlng);\n        },\n\n        createLayer: function (klass, latlngs, options) {\n            options = L.Util.extend({editOptions: {editTools: this}}, options);\n            var layer = new klass(latlngs, options);\n            // 🍂namespace Editable\n            // 🍂event editable:created: LayerEvent\n            // Fired when a new feature (Marker, Polyline…) is created.\n            this.fireAndForward('editable:created', {layer: layer});\n            return layer;\n        },\n\n        createPolyline: function (latlngs, options) {\n            return this.createLayer(options && options.polylineClass || this.options.polylineClass, latlngs, options);\n        },\n\n        createPolygon: function (latlngs, options) {\n            return this.createLayer(options && options.polygonClass || this.options.polygonClass, latlngs, options);\n        },\n\n        createMarker: function (latlng, options) {\n            return this.createLayer(options && options.markerClass || this.options.markerClass, latlng, options);\n        },\n\n        createRectangle: function (bounds, options) {\n            return this.createLayer(options && options.rectangleClass || this.options.rectangleClass, bounds, options);\n        },\n\n        createCircle: function (latlng, options) {\n            return this.createLayer(options && options.circleClass || this.options.circleClass, latlng, options);\n        }\n\n    });\n\n    L.extend(L.Editable, {\n\n        makeCancellable: function (e) {\n            e.cancel = function () {\n                e._cancelled = true;\n            };\n        }\n\n    });\n\n    // 🍂namespace Map; 🍂class Map\n    // Leaflet.Editable add options and events to the `L.Map` object.\n    // See `Editable` events for the list of events fired on the Map.\n    // 🍂example\n    //\n    // ```js\n    // var map = L.map('map', {\n    //  editable: true,\n    //  editOptions: {\n    //    …\n    // }\n    // });\n    // ```\n    // 🍂section Editable Map Options\n    L.Map.mergeOptions({\n\n        // 🍂namespace Map\n        // 🍂section Map Options\n        // 🍂option editToolsClass: class = L.Editable\n        // Class to be used as vertex, for path editing.\n        editToolsClass: L.Editable,\n\n        // 🍂option editable: boolean = false\n        // Whether to create a L.Editable instance at map init.\n        editable: false,\n\n        // 🍂option editOptions: hash = {}\n        // Options to pass to L.Editable when instanciating.\n        editOptions: {}\n\n    });\n\n    L.Map.addInitHook(function () {\n\n        this.whenReady(function () {\n            if (this.options.editable) {\n                this.editTools = new this.options.editToolsClass(this, this.options.editOptions);\n            }\n        });\n\n    });\n\n    L.Editable.VertexIcon = L.DivIcon.extend({\n\n        options: {\n            iconSize: new L.Point(8, 8)\n        }\n\n    });\n\n    L.Editable.TouchVertexIcon = L.Editable.VertexIcon.extend({\n\n        options: {\n            iconSize: new L.Point(20, 20)\n        }\n\n    });\n\n\n    // 🍂namespace Editable; 🍂class VertexMarker; Handler for dragging path vertices.\n    L.Editable.VertexMarker = L.Marker.extend({\n\n        options: {\n            draggable: true,\n            className: 'leaflet-div-icon leaflet-vertex-icon'\n        },\n\n\n        // 🍂section Public methods\n        // The marker used to handle path vertex. You will usually interact with a `VertexMarker`\n        // instance when listening for events like `editable:vertex:ctrlclick`.\n\n        initialize: function (latlng, latlngs, editor, options) {\n            // We don't use this._latlng, because on drag Leaflet replace it while\n            // we want to keep reference.\n            this.latlng = latlng;\n            this.latlngs = latlngs;\n            this.editor = editor;\n            L.Marker.prototype.initialize.call(this, latlng, options);\n            this.options.icon = this.editor.tools.createVertexIcon({className: this.options.className});\n            this.latlng.__vertex = this;\n            this.editor.editLayer.addLayer(this);\n            this.setZIndexOffset(editor.tools._lastZIndex + 1);\n        },\n\n        onAdd: function (map) {\n            L.Marker.prototype.onAdd.call(this, map);\n            this.on('drag', this.onDrag);\n            this.on('dragstart', this.onDragStart);\n            this.on('dragend', this.onDragEnd);\n            this.on('mouseup', this.onMouseup);\n            this.on('click', this.onClick);\n            this.on('contextmenu', this.onContextMenu);\n            this.on('mousedown touchstart', this.onMouseDown);\n            this.addMiddleMarkers();\n        },\n\n        onRemove: function (map) {\n            if (this.middleMarker) this.middleMarker.delete();\n            delete this.latlng.__vertex;\n            this.off('drag', this.onDrag);\n            this.off('dragstart', this.onDragStart);\n            this.off('dragend', this.onDragEnd);\n            this.off('mouseup', this.onMouseup);\n            this.off('click', this.onClick);\n            this.off('contextmenu', this.onContextMenu);\n            this.off('mousedown touchstart', this.onMouseDown);\n            L.Marker.prototype.onRemove.call(this, map);\n        },\n\n        onDrag: function (e) {\n            e.vertex = this;\n            this.editor.onVertexMarkerDrag(e);\n            var iconPos = L.DomUtil.getPosition(this._icon),\n                latlng = this._map.layerPointToLatLng(iconPos);\n            this.latlng.update(latlng);\n            this._latlng = this.latlng;  // Push back to Leaflet our reference.\n            this.editor.refresh();\n            if (this.middleMarker) this.middleMarker.updateLatLng();\n            var next = this.getNext();\n            if (next && next.middleMarker) next.middleMarker.updateLatLng();\n        },\n\n        onDragStart: function (e) {\n            e.vertex = this;\n            this.editor.onVertexMarkerDragStart(e);\n        },\n\n        onDragEnd: function (e) {\n            e.vertex = this;\n            this.editor.onVertexMarkerDragEnd(e);\n        },\n\n        onClick: function (e) {\n            e.vertex = this;\n            this.editor.onVertexMarkerClick(e);\n        },\n\n        onMouseup: function (e) {\n            L.DomEvent.stop(e);\n            e.vertex = this;\n            this.editor.map.fire('mouseup', e);\n        },\n\n        onContextMenu: function (e) {\n            e.vertex = this;\n            this.editor.onVertexMarkerContextMenu(e);\n        },\n\n        onMouseDown: function (e) {\n            e.vertex = this;\n            this.editor.onVertexMarkerMouseDown(e);\n        },\n\n        // 🍂method delete()\n        // Delete a vertex and the related LatLng.\n        delete: function () {\n            var next = this.getNext();  // Compute before changing latlng\n            this.latlngs.splice(this.getIndex(), 1);\n            this.editor.editLayer.removeLayer(this);\n            this.editor.onVertexDeleted({latlng: this.latlng, vertex: this});\n            if (!this.latlngs.length) this.editor.deleteShape(this.latlngs);\n            if (next) next.resetMiddleMarker();\n            this.editor.refresh();\n        },\n\n        // 🍂method getIndex(): int\n        // Get the index of the current vertex among others of the same LatLngs group.\n        getIndex: function () {\n            return this.latlngs.indexOf(this.latlng);\n        },\n\n        // 🍂method getLastIndex(): int\n        // Get last vertex index of the LatLngs group of the current vertex.\n        getLastIndex: function () {\n            return this.latlngs.length - 1;\n        },\n\n        // 🍂method getPrevious(): VertexMarker\n        // Get the previous VertexMarker in the same LatLngs group.\n        getPrevious: function () {\n            if (this.latlngs.length < 2) return;\n            var index = this.getIndex(),\n                previousIndex = index - 1;\n            if (index === 0 && this.editor.CLOSED) previousIndex = this.getLastIndex();\n            var previous = this.latlngs[previousIndex];\n            if (previous) return previous.__vertex;\n        },\n\n        // 🍂method getNext(): VertexMarker\n        // Get the next VertexMarker in the same LatLngs group.\n        getNext: function () {\n            if (this.latlngs.length < 2) return;\n            var index = this.getIndex(),\n                nextIndex = index + 1;\n            if (index === this.getLastIndex() && this.editor.CLOSED) nextIndex = 0;\n            var next = this.latlngs[nextIndex];\n            if (next) return next.__vertex;\n        },\n\n        addMiddleMarker: function (previous) {\n            if (!this.editor.hasMiddleMarkers()) return;\n            previous = previous || this.getPrevious();\n            if (previous && !this.middleMarker) this.middleMarker = this.editor.addMiddleMarker(previous, this, this.latlngs, this.editor);\n        },\n\n        addMiddleMarkers: function () {\n            if (!this.editor.hasMiddleMarkers()) return;\n            var previous = this.getPrevious();\n            if (previous) this.addMiddleMarker(previous);\n            var next = this.getNext();\n            if (next) next.resetMiddleMarker();\n        },\n\n        resetMiddleMarker: function () {\n            if (this.middleMarker) this.middleMarker.delete();\n            this.addMiddleMarker();\n        },\n\n        // 🍂method split()\n        // Split the vertex LatLngs group at its index, if possible.\n        split: function () {\n            if (!this.editor.splitShape) return;  // Only for PolylineEditor\n            this.editor.splitShape(this.latlngs, this.getIndex());\n        },\n\n        // 🍂method continue()\n        // Continue the vertex LatLngs from this vertex. Only active for first and last vertices of a Polyline.\n        continue: function () {\n            if (!this.editor.continueBackward) return;  // Only for PolylineEditor\n            var index = this.getIndex();\n            if (index === 0) this.editor.continueBackward(this.latlngs);\n            else if (index === this.getLastIndex()) this.editor.continueForward(this.latlngs);\n        }\n\n    });\n\n    L.Editable.mergeOptions({\n\n        // 🍂namespace Editable\n        // 🍂option vertexMarkerClass: class = VertexMarker\n        // Class to be used as vertex, for path editing.\n        vertexMarkerClass: L.Editable.VertexMarker\n\n    });\n\n    L.Editable.MiddleMarker = L.Marker.extend({\n\n        options: {\n            opacity: 0.5,\n            className: 'leaflet-div-icon leaflet-middle-icon',\n            draggable: true\n        },\n\n        initialize: function (left, right, latlngs, editor, options) {\n            this.left = left;\n            this.right = right;\n            this.editor = editor;\n            this.latlngs = latlngs;\n            L.Marker.prototype.initialize.call(this, this.computeLatLng(), options);\n            this._opacity = this.options.opacity;\n            this.options.icon = this.editor.tools.createVertexIcon({className: this.options.className});\n            this.editor.editLayer.addLayer(this);\n            this.setVisibility();\n        },\n\n        setVisibility: function () {\n            var leftPoint = this._map.latLngToContainerPoint(this.left.latlng),\n                rightPoint = this._map.latLngToContainerPoint(this.right.latlng),\n                size = L.point(this.options.icon.options.iconSize);\n            if (leftPoint.distanceTo(rightPoint) < size.x * 3) this.hide();\n            else this.show();\n        },\n\n        show: function () {\n            this.setOpacity(this._opacity);\n        },\n\n        hide: function () {\n            this.setOpacity(0);\n        },\n\n        updateLatLng: function () {\n            this.setLatLng(this.computeLatLng());\n            this.setVisibility();\n        },\n\n        computeLatLng: function () {\n            var leftPoint = this.editor.map.latLngToContainerPoint(this.left.latlng),\n                rightPoint = this.editor.map.latLngToContainerPoint(this.right.latlng),\n                y = (leftPoint.y + rightPoint.y) / 2,\n                x = (leftPoint.x + rightPoint.x) / 2;\n            return this.editor.map.containerPointToLatLng([x, y]);\n        },\n\n        onAdd: function (map) {\n            L.Marker.prototype.onAdd.call(this, map);\n            L.DomEvent.on(this._icon, 'mousedown touchstart', this.onMouseDown, this);\n            map.on('zoomend', this.setVisibility, this);\n        },\n\n        onRemove: function (map) {\n            delete this.right.middleMarker;\n            L.DomEvent.off(this._icon, 'mousedown touchstart', this.onMouseDown, this);\n            map.off('zoomend', this.setVisibility, this);\n            L.Marker.prototype.onRemove.call(this, map);\n        },\n\n        onMouseDown: function (e) {\n            var iconPos = L.DomUtil.getPosition(this._icon),\n                latlng = this.editor.map.layerPointToLatLng(iconPos);\n            e = {\n                originalEvent: e,\n                latlng: latlng\n            };\n            if (this.options.opacity === 0) return;\n            L.Editable.makeCancellable(e);\n            this.editor.onMiddleMarkerMouseDown(e);\n            if (e._cancelled) return;\n            this.latlngs.splice(this.index(), 0, e.latlng);\n            this.editor.refresh();\n            var icon = this._icon;\n            var marker = this.editor.addVertexMarker(e.latlng, this.latlngs);\n            /* Hack to workaround browser not firing touchend when element is no more on DOM */\n            var parent = marker._icon.parentNode;\n            parent.removeChild(marker._icon);\n            marker._icon = icon;\n            parent.appendChild(marker._icon);\n            marker._initIcon();\n            marker._initInteraction();\n            marker.setOpacity(1);\n            /* End hack */\n            // Transfer ongoing dragging to real marker\n            L.Draggable._dragging = false;\n            marker.dragging._draggable._onDown(e.originalEvent);\n            this.delete();\n        },\n\n        delete: function () {\n            this.editor.editLayer.removeLayer(this);\n        },\n\n        index: function () {\n            return this.latlngs.indexOf(this.right.latlng);\n        }\n\n    });\n\n    L.Editable.mergeOptions({\n\n        // 🍂namespace Editable\n        // 🍂option middleMarkerClass: class = VertexMarker\n        // Class to be used as middle vertex, pulled by the user to create a new point in the middle of a path.\n        middleMarkerClass: L.Editable.MiddleMarker\n\n    });\n\n    // 🍂namespace Editable; 🍂class BaseEditor; 🍂aka L.Editable.BaseEditor\n    // When editing a feature (Marker, Polyline…), an editor is attached to it. This\n    // editor basically knows how to handle the edition.\n    L.Editable.BaseEditor = L.Handler.extend({\n\n        initialize: function (map, feature, options) {\n            L.setOptions(this, options);\n            this.map = map;\n            this.feature = feature;\n            this.feature.editor = this;\n            this.editLayer = new L.LayerGroup();\n            this.tools = this.options.editTools || map.editTools;\n        },\n\n        // 🍂method enable(): this\n        // Set up the drawing tools for the feature to be editable.\n        addHooks: function () {\n            if (this.isConnected()) this.onFeatureAdd();\n            else this.feature.once('add', this.onFeatureAdd, this);\n            this.onEnable();\n            this.feature.on(this._getEvents(), this);\n            return;\n        },\n\n        // 🍂method disable(): this\n        // Remove the drawing tools for the feature.\n        removeHooks: function () {\n            this.feature.off(this._getEvents(), this);\n            if (this.feature.dragging) this.feature.dragging.disable();\n            this.editLayer.clearLayers();\n            this.tools.editLayer.removeLayer(this.editLayer);\n            this.onDisable();\n            if (this._drawing) this.cancelDrawing();\n            return;\n        },\n\n        // 🍂method drawing(): boolean\n        // Return true if any drawing action is ongoing with this editor.\n        drawing: function () {\n            return !!this._drawing;\n        },\n\n        reset: function () {},\n\n        onFeatureAdd: function () {\n            this.tools.editLayer.addLayer(this.editLayer);\n            if (this.feature.dragging) this.feature.dragging.enable();\n        },\n\n        hasMiddleMarkers: function () {\n            return !this.options.skipMiddleMarkers && !this.tools.options.skipMiddleMarkers;\n        },\n\n        fireAndForward: function (type, e) {\n            e = e || {};\n            e.layer = this.feature;\n            this.feature.fire(type, e);\n            this.tools.fireAndForward(type, e);\n        },\n\n        onEnable: function () {\n            // 🍂namespace Editable\n            // 🍂event editable:enable: Event\n            // Fired when an existing feature is ready to be edited.\n            this.fireAndForward('editable:enable');\n        },\n\n        onDisable: function () {\n            // 🍂namespace Editable\n            // 🍂event editable:disable: Event\n            // Fired when an existing feature is not ready anymore to be edited.\n            this.fireAndForward('editable:disable');\n        },\n\n        onEditing: function () {\n            // 🍂namespace Editable\n            // 🍂event editable:editing: Event\n            // Fired as soon as any change is made to the feature geometry.\n            this.fireAndForward('editable:editing');\n        },\n\n        onStartDrawing: function () {\n            // 🍂namespace Editable\n            // 🍂section Drawing events\n            // 🍂event editable:drawing:start: Event\n            // Fired when a feature is to be drawn.\n            this.fireAndForward('editable:drawing:start');\n        },\n\n        onEndDrawing: function () {\n            // 🍂namespace Editable\n            // 🍂section Drawing events\n            // 🍂event editable:drawing:end: Event\n            // Fired when a feature is not drawn anymore.\n            this.fireAndForward('editable:drawing:end');\n        },\n\n        onCancelDrawing: function () {\n            // 🍂namespace Editable\n            // 🍂section Drawing events\n            // 🍂event editable:drawing:cancel: Event\n            // Fired when user cancel drawing while a feature is being drawn.\n            this.fireAndForward('editable:drawing:cancel');\n        },\n\n        onCommitDrawing: function (e) {\n            // 🍂namespace Editable\n            // 🍂section Drawing events\n            // 🍂event editable:drawing:commit: Event\n            // Fired when user finish drawing a feature.\n            this.fireAndForward('editable:drawing:commit', e);\n        },\n\n        onDrawingMouseDown: function (e) {\n            // 🍂namespace Editable\n            // 🍂section Drawing events\n            // 🍂event editable:drawing:mousedown: Event\n            // Fired when user `mousedown` while drawing.\n            this.fireAndForward('editable:drawing:mousedown', e);\n        },\n\n        onDrawingMouseUp: function (e) {\n            // 🍂namespace Editable\n            // 🍂section Drawing events\n            // 🍂event editable:drawing:mouseup: Event\n            // Fired when user `mouseup` while drawing.\n            this.fireAndForward('editable:drawing:mouseup', e);\n        },\n\n        startDrawing: function () {\n            if (!this._drawing) this._drawing = L.Editable.FORWARD;\n            this.tools.registerForDrawing(this);\n            this.onStartDrawing();\n        },\n\n        commitDrawing: function (e) {\n            this.onCommitDrawing(e);\n            this.endDrawing();\n        },\n\n        cancelDrawing: function () {\n            // If called during a vertex drag, the vertex will be removed before\n            // the mouseup fires on it. This is a workaround. Maybe better fix is\n            // To have L.Draggable reset it's status on disable (Leaflet side).\n            L.Draggable._dragging = false;\n            this.onCancelDrawing();\n            this.endDrawing();\n        },\n\n        endDrawing: function () {\n            this._drawing = false;\n            this.tools.unregisterForDrawing(this);\n            this.onEndDrawing();\n        },\n\n        onDrawingClick: function (e) {\n            if (!this.drawing()) return;\n            L.Editable.makeCancellable(e);\n            // 🍂namespace Editable\n            // 🍂section Drawing events\n            // 🍂event editable:drawing:click: CancelableEvent\n            // Fired when user `click` while drawing, before any internal action is being processed.\n            this.fireAndForward('editable:drawing:click', e);\n            if (e._cancelled) return;\n            if (!this.isConnected()) this.connect(e);\n            this.processDrawingClick(e);\n        },\n\n        isConnected: function () {\n            return this.map.hasLayer(this.feature);\n        },\n\n        connect: function (e) {\n            this.tools.connectCreatedToMap(this.feature);\n            this.tools.editLayer.addLayer(this.editLayer);\n        },\n\n        onMove: function (e) {\n            // 🍂namespace Editable\n            // 🍂section Drawing events\n            // 🍂event editable:drawing:move: Event\n            // Fired when `move` mouse while drawing, while dragging a marker, and while dragging a vertex.\n            this.fireAndForward('editable:drawing:move', e);\n        },\n\n        onDrawingMouseMove: function (e) {\n            this.onMove(e);\n        },\n\n        _getEvents: function () {\n            return {\n                dragstart: this.onDragStart,\n                drag: this.onDrag,\n                dragend: this.onDragEnd,\n                remove: this.disable\n            };\n        },\n\n        onDragStart: function (e) {\n            this.onEditing();\n            // 🍂namespace Editable\n            // 🍂event editable:dragstart: Event\n            // Fired before a path feature is dragged.\n            this.fireAndForward('editable:dragstart', e);\n        },\n\n        onDrag: function (e) {\n            this.onMove(e);\n            // 🍂namespace Editable\n            // 🍂event editable:drag: Event\n            // Fired when a path feature is being dragged.\n            this.fireAndForward('editable:drag', e);\n        },\n\n        onDragEnd: function (e) {\n            // 🍂namespace Editable\n            // 🍂event editable:dragend: Event\n            // Fired after a path feature has been dragged.\n            this.fireAndForward('editable:dragend', e);\n        }\n\n    });\n\n    // 🍂namespace Editable; 🍂class MarkerEditor; 🍂aka L.Editable.MarkerEditor\n    // 🍂inherits BaseEditor\n    // Editor for Marker.\n    L.Editable.MarkerEditor = L.Editable.BaseEditor.extend({\n\n        onDrawingMouseMove: function (e) {\n            L.Editable.BaseEditor.prototype.onDrawingMouseMove.call(this, e);\n            if (this._drawing) this.feature.setLatLng(e.latlng);\n        },\n\n        processDrawingClick: function (e) {\n            // 🍂namespace Editable\n            // 🍂section Drawing events\n            // 🍂event editable:drawing:clicked: Event\n            // Fired when user `click` while drawing, after all internal actions.\n            this.fireAndForward('editable:drawing:clicked', e);\n            this.commitDrawing(e);\n        },\n\n        connect: function (e) {\n            // On touch, the latlng has not been updated because there is\n            // no mousemove.\n            if (e) this.feature._latlng = e.latlng;\n            L.Editable.BaseEditor.prototype.connect.call(this, e);\n        }\n\n    });\n\n    // 🍂namespace Editable; 🍂class PathEditor; 🍂aka L.Editable.PathEditor\n    // 🍂inherits BaseEditor\n    // Base class for all path editors.\n    L.Editable.PathEditor = L.Editable.BaseEditor.extend({\n\n        CLOSED: false,\n        MIN_VERTEX: 2,\n\n        addHooks: function () {\n            L.Editable.BaseEditor.prototype.addHooks.call(this);\n            if (this.feature) this.initVertexMarkers();\n            return this;\n        },\n\n        initVertexMarkers: function (latlngs) {\n            if (!this.enabled()) return;\n            latlngs = latlngs || this.getLatLngs();\n            if (L.Polyline._flat(latlngs)) this.addVertexMarkers(latlngs);\n            else for (var i = 0; i < latlngs.length; i++) this.initVertexMarkers(latlngs[i]);\n        },\n\n        getLatLngs: function () {\n            return this.feature.getLatLngs();\n        },\n\n        // 🍂method reset()\n        // Rebuild edit elements (Vertex, MiddleMarker, etc.).\n        reset: function () {\n            this.editLayer.clearLayers();\n            this.initVertexMarkers();\n        },\n\n        addVertexMarker: function (latlng, latlngs) {\n            return new this.tools.options.vertexMarkerClass(latlng, latlngs, this);\n        },\n\n        addVertexMarkers: function (latlngs) {\n            for (var i = 0; i < latlngs.length; i++) {\n                this.addVertexMarker(latlngs[i], latlngs);\n            }\n        },\n\n        refreshVertexMarkers: function (latlngs) {\n            latlngs = latlngs || this.getDefaultLatLngs();\n            for (var i = 0; i < latlngs.length; i++) {\n                latlngs[i].__vertex.update();\n            }\n        },\n\n        addMiddleMarker: function (left, right, latlngs) {\n            return new this.tools.options.middleMarkerClass(left, right, latlngs, this);\n        },\n\n        onVertexMarkerClick: function (e) {\n            L.Editable.makeCancellable(e);\n            // 🍂namespace Editable\n            // 🍂section Vertex events\n            // 🍂event editable:vertex:click: CancelableVertexEvent\n            // Fired when a `click` is issued on a vertex, before any internal action is being processed.\n            this.fireAndForward('editable:vertex:click', e);\n            if (e._cancelled) return;\n            if (this.tools.drawing() && this.tools._drawingEditor !== this) return;\n            var index = e.vertex.getIndex(), commit;\n            if (e.originalEvent.ctrlKey) {\n                this.onVertexMarkerCtrlClick(e);\n            } else if (e.originalEvent.altKey) {\n                this.onVertexMarkerAltClick(e);\n            } else if (e.originalEvent.shiftKey) {\n                this.onVertexMarkerShiftClick(e);\n            } else if (e.originalEvent.metaKey) {\n                this.onVertexMarkerMetaKeyClick(e);\n            } else if (index === e.vertex.getLastIndex() && this._drawing === L.Editable.FORWARD) {\n                if (index >= this.MIN_VERTEX - 1) commit = true;\n            } else if (index === 0 && this._drawing === L.Editable.BACKWARD && this._drawnLatLngs.length >= this.MIN_VERTEX) {\n                commit = true;\n            } else if (index === 0 && this._drawing === L.Editable.FORWARD && this._drawnLatLngs.length >= this.MIN_VERTEX && this.CLOSED) {\n                commit = true;  // Allow to close on first point also for polygons\n            } else {\n                this.onVertexRawMarkerClick(e);\n            }\n            // 🍂namespace Editable\n            // 🍂section Vertex events\n            // 🍂event editable:vertex:clicked: VertexEvent\n            // Fired when a `click` is issued on a vertex, after all internal actions.\n            this.fireAndForward('editable:vertex:clicked', e);\n            if (commit) this.commitDrawing(e);\n        },\n\n        onVertexRawMarkerClick: function (e) {\n            // 🍂namespace Editable\n            // 🍂section Vertex events\n            // 🍂event editable:vertex:rawclick: CancelableVertexEvent\n            // Fired when a `click` is issued on a vertex without any special key and without being in drawing mode.\n            this.fireAndForward('editable:vertex:rawclick', e);\n            if (e._cancelled) return;\n            if (!this.vertexCanBeDeleted(e.vertex)) return;\n            e.vertex.delete();\n        },\n\n        vertexCanBeDeleted: function (vertex) {\n            return vertex.latlngs.length > this.MIN_VERTEX;\n        },\n\n        onVertexDeleted: function (e) {\n            // 🍂namespace Editable\n            // 🍂section Vertex events\n            // 🍂event editable:vertex:deleted: VertexEvent\n            // Fired after a vertex has been deleted by user.\n            this.fireAndForward('editable:vertex:deleted', e);\n        },\n\n        onVertexMarkerCtrlClick: function (e) {\n            // 🍂namespace Editable\n            // 🍂section Vertex events\n            // 🍂event editable:vertex:ctrlclick: VertexEvent\n            // Fired when a `click` with `ctrlKey` is issued on a vertex.\n            this.fireAndForward('editable:vertex:ctrlclick', e);\n        },\n\n        onVertexMarkerShiftClick: function (e) {\n            // 🍂namespace Editable\n            // 🍂section Vertex events\n            // 🍂event editable:vertex:shiftclick: VertexEvent\n            // Fired when a `click` with `shiftKey` is issued on a vertex.\n            this.fireAndForward('editable:vertex:shiftclick', e);\n        },\n\n        onVertexMarkerMetaKeyClick: function (e) {\n            // 🍂namespace Editable\n            // 🍂section Vertex events\n            // 🍂event editable:vertex:metakeyclick: VertexEvent\n            // Fired when a `click` with `metaKey` is issued on a vertex.\n            this.fireAndForward('editable:vertex:metakeyclick', e);\n        },\n\n        onVertexMarkerAltClick: function (e) {\n            // 🍂namespace Editable\n            // 🍂section Vertex events\n            // 🍂event editable:vertex:altclick: VertexEvent\n            // Fired when a `click` with `altKey` is issued on a vertex.\n            this.fireAndForward('editable:vertex:altclick', e);\n        },\n\n        onVertexMarkerContextMenu: function (e) {\n            // 🍂namespace Editable\n            // 🍂section Vertex events\n            // 🍂event editable:vertex:contextmenu: VertexEvent\n            // Fired when a `contextmenu` is issued on a vertex.\n            this.fireAndForward('editable:vertex:contextmenu', e);\n        },\n\n        onVertexMarkerMouseDown: function (e) {\n            // 🍂namespace Editable\n            // 🍂section Vertex events\n            // 🍂event editable:vertex:mousedown: VertexEvent\n            // Fired when user `mousedown` a vertex.\n            this.fireAndForward('editable:vertex:mousedown', e);\n        },\n\n        onMiddleMarkerMouseDown: function (e) {\n            // 🍂namespace Editable\n            // 🍂section MiddleMarker events\n            // 🍂event editable:middlemarker:mousedown: VertexEvent\n            // Fired when user `mousedown` a middle marker.\n            this.fireAndForward('editable:middlemarker:mousedown', e);\n        },\n\n        onVertexMarkerDrag: function (e) {\n            this.onMove(e);\n            if (this.feature._bounds) this.extendBounds(e);\n            // 🍂namespace Editable\n            // 🍂section Vertex events\n            // 🍂event editable:vertex:drag: VertexEvent\n            // Fired when a vertex is dragged by user.\n            this.fireAndForward('editable:vertex:drag', e);\n        },\n\n        onVertexMarkerDragStart: function (e) {\n            // 🍂namespace Editable\n            // 🍂section Vertex events\n            // 🍂event editable:vertex:dragstart: VertexEvent\n            // Fired before a vertex is dragged by user.\n            this.fireAndForward('editable:vertex:dragstart', e);\n        },\n\n        onVertexMarkerDragEnd: function (e) {\n            // 🍂namespace Editable\n            // 🍂section Vertex events\n            // 🍂event editable:vertex:dragend: VertexEvent\n            // Fired after a vertex is dragged by user.\n            this.fireAndForward('editable:vertex:dragend', e);\n        },\n\n        setDrawnLatLngs: function (latlngs) {\n            this._drawnLatLngs = latlngs || this.getDefaultLatLngs();\n        },\n\n        startDrawing: function () {\n            if (!this._drawnLatLngs) this.setDrawnLatLngs();\n            L.Editable.BaseEditor.prototype.startDrawing.call(this);\n        },\n\n        startDrawingForward: function () {\n            this.startDrawing();\n        },\n\n        endDrawing: function () {\n            this.tools.detachForwardLineGuide();\n            this.tools.detachBackwardLineGuide();\n            if (this._drawnLatLngs && this._drawnLatLngs.length < this.MIN_VERTEX) this.deleteShape(this._drawnLatLngs);\n            L.Editable.BaseEditor.prototype.endDrawing.call(this);\n            delete this._drawnLatLngs;\n        },\n\n        addLatLng: function (latlng) {\n            if (this._drawing === L.Editable.FORWARD) this._drawnLatLngs.push(latlng);\n            else this._drawnLatLngs.unshift(latlng);\n            this.feature._bounds.extend(latlng);\n            this.addVertexMarker(latlng, this._drawnLatLngs);\n            this.refresh();\n        },\n\n        newPointForward: function (latlng) {\n            this.addLatLng(latlng);\n            this.tools.attachForwardLineGuide();\n            this.tools.anchorForwardLineGuide(latlng);\n        },\n\n        newPointBackward: function (latlng) {\n            this.addLatLng(latlng);\n            this.tools.anchorBackwardLineGuide(latlng);\n        },\n\n        // 🍂namespace PathEditor\n        // 🍂method push()\n        // Programmatically add a point while drawing.\n        push: function (latlng) {\n            if (!latlng) return console.error('L.Editable.PathEditor.push expect a vaild latlng as parameter');\n            if (this._drawing === L.Editable.FORWARD) this.newPointForward(latlng);\n            else this.newPointBackward(latlng);\n        },\n\n        removeLatLng: function (latlng) {\n            latlng.__vertex.delete();\n            this.refresh();\n        },\n\n        // 🍂method pop(): L.LatLng or null\n        // Programmatically remove last point (if any) while drawing.\n        pop: function () {\n            if (this._drawnLatLngs.length <= 1) return;\n            var latlng;\n            if (this._drawing === L.Editable.FORWARD) latlng = this._drawnLatLngs[this._drawnLatLngs.length - 1];\n            else latlng = this._drawnLatLngs[0];\n            this.removeLatLng(latlng);\n            if (this._drawing === L.Editable.FORWARD) this.tools.anchorForwardLineGuide(this._drawnLatLngs[this._drawnLatLngs.length - 1]);\n            else this.tools.anchorForwardLineGuide(this._drawnLatLngs[0]);\n            return latlng;\n        },\n\n        processDrawingClick: function (e) {\n            if (e.vertex && e.vertex.editor === this) return;\n            if (this._drawing === L.Editable.FORWARD) this.newPointForward(e.latlng);\n            else this.newPointBackward(e.latlng);\n            this.fireAndForward('editable:drawing:clicked', e);\n        },\n\n        onDrawingMouseMove: function (e) {\n            L.Editable.BaseEditor.prototype.onDrawingMouseMove.call(this, e);\n            if (this._drawing) {\n                this.tools.moveForwardLineGuide(e.latlng);\n                this.tools.moveBackwardLineGuide(e.latlng);\n            }\n        },\n\n        refresh: function () {\n            this.feature.redraw();\n            this.onEditing();\n        },\n\n        // 🍂namespace PathEditor\n        // 🍂method newShape(latlng?: L.LatLng)\n        // Add a new shape (Polyline, Polygon) in a multi, and setup up drawing tools to draw it;\n        // if optional `latlng` is given, start a path at this point.\n        newShape: function (latlng) {\n            var shape = this.addNewEmptyShape();\n            if (!shape) return;\n            this.setDrawnLatLngs(shape[0] || shape);  // Polygon or polyline\n            this.startDrawingForward();\n            // 🍂namespace Editable\n            // 🍂section Shape events\n            // 🍂event editable:shape:new: ShapeEvent\n            // Fired when a new shape is created in a multi (Polygon or Polyline).\n            this.fireAndForward('editable:shape:new', {shape: shape});\n            if (latlng) this.newPointForward(latlng);\n        },\n\n        deleteShape: function (shape, latlngs) {\n            var e = {shape: shape};\n            L.Editable.makeCancellable(e);\n            // 🍂namespace Editable\n            // 🍂section Shape events\n            // 🍂event editable:shape:delete: CancelableShapeEvent\n            // Fired before a new shape is deleted in a multi (Polygon or Polyline).\n            this.fireAndForward('editable:shape:delete', e);\n            if (e._cancelled) return;\n            shape = this._deleteShape(shape, latlngs);\n            if (this.ensureNotFlat) this.ensureNotFlat();  // Polygon.\n            this.feature.setLatLngs(this.getLatLngs());  // Force bounds reset.\n            this.refresh();\n            this.reset();\n            // 🍂namespace Editable\n            // 🍂section Shape events\n            // 🍂event editable:shape:deleted: ShapeEvent\n            // Fired after a new shape is deleted in a multi (Polygon or Polyline).\n            this.fireAndForward('editable:shape:deleted', {shape: shape});\n            return shape;\n        },\n\n        _deleteShape: function (shape, latlngs) {\n            latlngs = latlngs || this.getLatLngs();\n            if (!latlngs.length) return;\n            var self = this,\n                inplaceDelete = function (latlngs, shape) {\n                    // Called when deleting a flat latlngs\n                    shape = latlngs.splice(0, Number.MAX_VALUE);\n                    return shape;\n                },\n                spliceDelete = function (latlngs, shape) {\n                    // Called when removing a latlngs inside an array\n                    latlngs.splice(latlngs.indexOf(shape), 1);\n                    if (!latlngs.length) self._deleteShape(latlngs);\n                    return shape;\n                };\n            if (latlngs === shape) return inplaceDelete(latlngs, shape);\n            for (var i = 0; i < latlngs.length; i++) {\n                if (latlngs[i] === shape) return spliceDelete(latlngs, shape);\n                else if (latlngs[i].indexOf(shape) !== -1) return spliceDelete(latlngs[i], shape);\n            }\n        },\n\n        // 🍂namespace PathEditor\n        // 🍂method deleteShapeAt(latlng: L.LatLng): Array\n        // Remove a path shape at the given `latlng`.\n        deleteShapeAt: function (latlng) {\n            var shape = this.feature.shapeAt(latlng);\n            if (shape) return this.deleteShape(shape);\n        },\n\n        // 🍂method appendShape(shape: Array)\n        // Append a new shape to the Polygon or Polyline.\n        appendShape: function (shape) {\n            this.insertShape(shape);\n        },\n\n        // 🍂method prependShape(shape: Array)\n        // Prepend a new shape to the Polygon or Polyline.\n        prependShape: function (shape) {\n            this.insertShape(shape, 0);\n        },\n\n        // 🍂method insertShape(shape: Array, index: int)\n        // Insert a new shape to the Polygon or Polyline at given index (default is to append).\n        insertShape: function (shape, index) {\n            this.ensureMulti();\n            shape = this.formatShape(shape);\n            if (typeof index === 'undefined') index = this.feature._latlngs.length;\n            this.feature._latlngs.splice(index, 0, shape);\n            this.feature.redraw();\n            if (this._enabled) this.reset();\n        },\n\n        extendBounds: function (e) {\n            this.feature._bounds.extend(e.vertex.latlng);\n        },\n\n        onDragStart: function (e) {\n            this.editLayer.clearLayers();\n            L.Editable.BaseEditor.prototype.onDragStart.call(this, e);\n        },\n\n        onDragEnd: function (e) {\n            this.initVertexMarkers();\n            L.Editable.BaseEditor.prototype.onDragEnd.call(this, e);\n        }\n\n    });\n\n    // 🍂namespace Editable; 🍂class PolylineEditor; 🍂aka L.Editable.PolylineEditor\n    // 🍂inherits PathEditor\n    L.Editable.PolylineEditor = L.Editable.PathEditor.extend({\n\n        startDrawingBackward: function () {\n            this._drawing = L.Editable.BACKWARD;\n            this.startDrawing();\n        },\n\n        // 🍂method continueBackward(latlngs?: Array)\n        // Set up drawing tools to continue the line backward.\n        continueBackward: function (latlngs) {\n            if (this.drawing()) return;\n            latlngs = latlngs || this.getDefaultLatLngs();\n            this.setDrawnLatLngs(latlngs);\n            if (latlngs.length > 0) {\n                this.tools.attachBackwardLineGuide();\n                this.tools.anchorBackwardLineGuide(latlngs[0]);\n            }\n            this.startDrawingBackward();\n        },\n\n        // 🍂method continueForward(latlngs?: Array)\n        // Set up drawing tools to continue the line forward.\n        continueForward: function (latlngs) {\n            if (this.drawing()) return;\n            latlngs = latlngs || this.getDefaultLatLngs();\n            this.setDrawnLatLngs(latlngs);\n            if (latlngs.length > 0) {\n                this.tools.attachForwardLineGuide();\n                this.tools.anchorForwardLineGuide(latlngs[latlngs.length - 1]);\n            }\n            this.startDrawingForward();\n        },\n\n        getDefaultLatLngs: function (latlngs) {\n            latlngs = latlngs || this.feature._latlngs;\n            if (!latlngs.length || latlngs[0] instanceof L.LatLng) return latlngs;\n            else return this.getDefaultLatLngs(latlngs[0]);\n        },\n\n        ensureMulti: function () {\n            if (this.feature._latlngs.length && L.Polyline._flat(this.feature._latlngs)) {\n                this.feature._latlngs = [this.feature._latlngs];\n            }\n        },\n\n        addNewEmptyShape: function () {\n            if (this.feature._latlngs.length) {\n                var shape = [];\n                this.appendShape(shape);\n                return shape;\n            } else {\n                return this.feature._latlngs;\n            }\n        },\n\n        formatShape: function (shape) {\n            if (L.Polyline._flat(shape)) return shape;\n            else if (shape[0]) return this.formatShape(shape[0]);\n        },\n\n        // 🍂method splitShape(latlngs?: Array, index: int)\n        // Split the given `latlngs` shape at index `index` and integrate new shape in instance `latlngs`.\n        splitShape: function (shape, index) {\n            if (!index || index >= shape.length - 1) return;\n            this.ensureMulti();\n            var shapeIndex = this.feature._latlngs.indexOf(shape);\n            if (shapeIndex === -1) return;\n            var first = shape.slice(0, index + 1),\n                second = shape.slice(index);\n            // We deal with reference, we don't want twice the same latlng around.\n            second[0] = L.latLng(second[0].lat, second[0].lng, second[0].alt);\n            this.feature._latlngs.splice(shapeIndex, 1, first, second);\n            this.refresh();\n            this.reset();\n        }\n\n    });\n\n    // 🍂namespace Editable; 🍂class PolygonEditor; 🍂aka L.Editable.PolygonEditor\n    // 🍂inherits PathEditor\n    L.Editable.PolygonEditor = L.Editable.PathEditor.extend({\n\n        CLOSED: true,\n        MIN_VERTEX: 3,\n\n        newPointForward: function (latlng) {\n            L.Editable.PathEditor.prototype.newPointForward.call(this, latlng);\n            if (!this.tools.backwardLineGuide._latlngs.length) this.tools.anchorBackwardLineGuide(latlng);\n            if (this._drawnLatLngs.length === 2) this.tools.attachBackwardLineGuide();\n        },\n\n        addNewEmptyHole: function (latlng) {\n            this.ensureNotFlat();\n            var latlngs = this.feature.shapeAt(latlng);\n            if (!latlngs) return;\n            var holes = [];\n            latlngs.push(holes);\n            return holes;\n        },\n\n        // 🍂method newHole(latlng?: L.LatLng, index: int)\n        // Set up drawing tools for creating a new hole on the Polygon. If the `latlng` param is given, a first point is created.\n        newHole: function (latlng) {\n            var holes = this.addNewEmptyHole(latlng);\n            if (!holes) return;\n            this.setDrawnLatLngs(holes);\n            this.startDrawingForward();\n            if (latlng) this.newPointForward(latlng);\n        },\n\n        addNewEmptyShape: function () {\n            if (this.feature._latlngs.length && this.feature._latlngs[0].length) {\n                var shape = [];\n                this.appendShape(shape);\n                return shape;\n            } else {\n                return this.feature._latlngs;\n            }\n        },\n\n        ensureMulti: function () {\n            if (this.feature._latlngs.length && L.Polyline._flat(this.feature._latlngs[0])) {\n                this.feature._latlngs = [this.feature._latlngs];\n            }\n        },\n\n        ensureNotFlat: function () {\n            if (!this.feature._latlngs.length || L.Polyline._flat(this.feature._latlngs)) this.feature._latlngs = [this.feature._latlngs];\n        },\n\n        vertexCanBeDeleted: function (vertex) {\n            var parent = this.feature.parentShape(vertex.latlngs),\n                idx = L.Util.indexOf(parent, vertex.latlngs);\n            if (idx > 0) return true;  // Holes can be totally deleted without removing the layer itself.\n            return L.Editable.PathEditor.prototype.vertexCanBeDeleted.call(this, vertex);\n        },\n\n        getDefaultLatLngs: function () {\n            if (!this.feature._latlngs.length) this.feature._latlngs.push([]);\n            return this.feature._latlngs[0];\n        },\n\n        formatShape: function (shape) {\n            // [[1, 2], [3, 4]] => must be nested\n            // [] => must be nested\n            // [[]] => is already nested\n            if (L.Polyline._flat(shape) && (!shape[0] || shape[0].length !== 0)) return [shape];\n            else return shape;\n        }\n\n    });\n\n    // 🍂namespace Editable; 🍂class RectangleEditor; 🍂aka L.Editable.RectangleEditor\n    // 🍂inherits PathEditor\n    L.Editable.RectangleEditor = L.Editable.PathEditor.extend({\n\n        CLOSED: true,\n        MIN_VERTEX: 4,\n\n        options: {\n            skipMiddleMarkers: true\n        },\n\n        extendBounds: function (e) {\n            var index = e.vertex.getIndex(),\n                next = e.vertex.getNext(),\n                previous = e.vertex.getPrevious(),\n                oppositeIndex = (index + 2) % 4,\n                opposite = e.vertex.latlngs[oppositeIndex],\n                bounds = new L.LatLngBounds(e.latlng, opposite);\n            // Update latlngs by hand to preserve order.\n            previous.latlng.update([e.latlng.lat, opposite.lng]);\n            next.latlng.update([opposite.lat, e.latlng.lng]);\n            this.updateBounds(bounds);\n            this.refreshVertexMarkers();\n        },\n\n        onDrawingMouseDown: function (e) {\n            L.Editable.PathEditor.prototype.onDrawingMouseDown.call(this, e);\n            this.connect();\n            var latlngs = this.getDefaultLatLngs();\n            // L.Polygon._convertLatLngs removes last latlng if it equals first point,\n            // which is the case here as all latlngs are [0, 0]\n            if (latlngs.length === 3) latlngs.push(e.latlng);\n            var bounds = new L.LatLngBounds(e.latlng, e.latlng);\n            this.updateBounds(bounds);\n            this.updateLatLngs(bounds);\n            this.refresh();\n            this.reset();\n            // Stop dragging map.\n            // L.Draggable has two workflows:\n            // - mousedown => mousemove => mouseup\n            // - touchstart => touchmove => touchend\n            // Problem: L.Map.Tap does not allow us to listen to touchstart, so we only\n            // can deal with mousedown, but then when in a touch device, we are dealing with\n            // simulated events (actually simulated by L.Map.Tap), which are no more taken\n            // into account by L.Draggable.\n            // Ref.: https://github.com/Leaflet/Leaflet.Editable/issues/103\n            e.originalEvent._simulated = false;\n            this.map.dragging._draggable._onUp(e.originalEvent);\n            // Now transfer ongoing drag action to the bottom right corner.\n            // Should we refine which corne will handle the drag according to\n            // drag direction?\n            latlngs[3].__vertex.dragging._draggable._onDown(e.originalEvent);\n        },\n\n        onDrawingMouseUp: function (e) {\n            this.commitDrawing(e);\n            e.originalEvent._simulated = false;\n            L.Editable.PathEditor.prototype.onDrawingMouseUp.call(this, e);\n        },\n\n        onDrawingMouseMove: function (e) {\n            e.originalEvent._simulated = false;\n            L.Editable.PathEditor.prototype.onDrawingMouseMove.call(this, e);\n        },\n\n\n        getDefaultLatLngs: function (latlngs) {\n            return latlngs || this.feature._latlngs[0];\n        },\n\n        updateBounds: function (bounds) {\n            this.feature._bounds = bounds;\n        },\n\n        updateLatLngs: function (bounds) {\n            var latlngs = this.getDefaultLatLngs(),\n                newLatlngs = this.feature._boundsToLatLngs(bounds);\n            // Keep references.\n            for (var i = 0; i < latlngs.length; i++) {\n                latlngs[i].update(newLatlngs[i]);\n            };\n        }\n\n    });\n\n    // 🍂namespace Editable; 🍂class CircleEditor; 🍂aka L.Editable.CircleEditor\n    // 🍂inherits PathEditor\n    L.Editable.CircleEditor = L.Editable.PathEditor.extend({\n\n        MIN_VERTEX: 2,\n\n        options: {\n            skipMiddleMarkers: true\n        },\n\n        initialize: function (map, feature, options) {\n            L.Editable.PathEditor.prototype.initialize.call(this, map, feature, options);\n            this._resizeLatLng = this.computeResizeLatLng();\n        },\n\n        computeResizeLatLng: function () {\n            // While circle is not added to the map, _radius is not set.\n            var delta = (this.feature._radius || this.feature._mRadius) * Math.cos(Math.PI / 4),\n                point = this.map.project(this.feature._latlng);\n            return this.map.unproject([point.x + delta, point.y - delta]);\n        },\n\n        updateResizeLatLng: function () {\n            this._resizeLatLng.update(this.computeResizeLatLng());\n            this._resizeLatLng.__vertex.update();\n        },\n\n        getLatLngs: function () {\n            return [this.feature._latlng, this._resizeLatLng];\n        },\n\n        getDefaultLatLngs: function () {\n            return this.getLatLngs();\n        },\n\n        onVertexMarkerDrag: function (e) {\n            if (e.vertex.getIndex() === 1) this.resize(e);\n            else this.updateResizeLatLng(e);\n            L.Editable.PathEditor.prototype.onVertexMarkerDrag.call(this, e);\n        },\n\n        resize: function (e) {\n            var radius = this.feature._latlng.distanceTo(e.latlng)\n            this.feature.setRadius(radius);\n        },\n\n        onDrawingMouseDown: function (e) {\n            L.Editable.PathEditor.prototype.onDrawingMouseDown.call(this, e);\n            this._resizeLatLng.update(e.latlng);\n            this.feature._latlng.update(e.latlng);\n            this.connect();\n            // Stop dragging map.\n            e.originalEvent._simulated = false;\n            this.map.dragging._draggable._onUp(e.originalEvent);\n            // Now transfer ongoing drag action to the radius handler.\n            this._resizeLatLng.__vertex.dragging._draggable._onDown(e.originalEvent);\n        },\n\n        onDrawingMouseUp: function (e) {\n            this.commitDrawing(e);\n            e.originalEvent._simulated = false;\n            L.Editable.PathEditor.prototype.onDrawingMouseUp.call(this, e);\n        },\n\n        onDrawingMouseMove: function (e) {\n            e.originalEvent._simulated = false;\n            L.Editable.PathEditor.prototype.onDrawingMouseMove.call(this, e);\n        },\n\n        onDrag: function (e) {\n            L.Editable.PathEditor.prototype.onDrag.call(this, e);\n            this.feature.dragging.updateLatLng(this._resizeLatLng);\n        }\n\n    });\n\n    // 🍂namespace Editable; 🍂class EditableMixin\n    // `EditableMixin` is included to `L.Polyline`, `L.Polygon`, `L.Rectangle`, `L.Circle`\n    // and `L.Marker`. It adds some methods to them.\n    // *When editing is enabled, the editor is accessible on the instance with the\n    // `editor` property.*\n    var EditableMixin = {\n\n        createEditor: function (map) {\n            map = map || this._map;\n            var tools = (this.options.editOptions || {}).editTools || map.editTools;\n            if (!tools) throw Error('Unable to detect Editable instance.')\n            var Klass = this.options.editorClass || this.getEditorClass(tools);\n            return new Klass(map, this, this.options.editOptions);\n        },\n\n        // 🍂method enableEdit(map?: L.Map): this.editor\n        // Enable editing, by creating an editor if not existing, and then calling `enable` on it.\n        enableEdit: function (map) {\n            if (!this.editor) this.createEditor(map);\n            this.editor.enable();\n            return this.editor;\n        },\n\n        // 🍂method editEnabled(): boolean\n        // Return true if current instance has an editor attached, and this editor is enabled.\n        editEnabled: function () {\n            return this.editor && this.editor.enabled();\n        },\n\n        // 🍂method disableEdit()\n        // Disable editing, also remove the editor property reference.\n        disableEdit: function () {\n            if (this.editor) {\n                this.editor.disable();\n                delete this.editor;\n            }\n        },\n\n        // 🍂method toggleEdit()\n        // Enable or disable editing, according to current status.\n        toggleEdit: function () {\n            if (this.editEnabled()) this.disableEdit();\n            else this.enableEdit();\n        },\n\n        _onEditableAdd: function () {\n            if (this.editor) this.enableEdit();\n        }\n\n    };\n\n    var PolylineMixin = {\n\n        getEditorClass: function (tools) {\n            return (tools && tools.options.polylineEditorClass) ? tools.options.polylineEditorClass : L.Editable.PolylineEditor;\n        },\n\n        shapeAt: function (latlng, latlngs) {\n            // We can have those cases:\n            // - latlngs are just a flat array of latlngs, use this\n            // - latlngs is an array of arrays of latlngs, loop over\n            var shape = null;\n            latlngs = latlngs || this._latlngs;\n            if (!latlngs.length) return shape;\n            else if (L.Polyline._flat(latlngs) && this.isInLatLngs(latlng, latlngs)) shape = latlngs;\n            else for (var i = 0; i < latlngs.length; i++) if (this.isInLatLngs(latlng, latlngs[i])) return latlngs[i];\n            return shape;\n        },\n\n        isInLatLngs: function (l, latlngs) {\n            if (!latlngs) return false;\n            var i, k, len, part = [], p,\n                w = this._clickTolerance();\n            this._projectLatlngs(latlngs, part, this._pxBounds);\n            part = part[0];\n            p = this._map.latLngToLayerPoint(l);\n\n            if (!this._pxBounds.contains(p)) { return false; }\n            for (i = 1, len = part.length, k = 0; i < len; k = i++) {\n\n                if (L.LineUtil.pointToSegmentDistance(p, part[k], part[i]) <= w) {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n    };\n\n    var PolygonMixin = {\n\n        getEditorClass: function (tools) {\n            return (tools && tools.options.polygonEditorClass) ? tools.options.polygonEditorClass : L.Editable.PolygonEditor;\n        },\n\n        shapeAt: function (latlng, latlngs) {\n            // We can have those cases:\n            // - latlngs are just a flat array of latlngs, use this\n            // - latlngs is an array of arrays of latlngs, this is a simple polygon (maybe with holes), use the first\n            // - latlngs is an array of arrays of arrays, this is a multi, loop over\n            var shape = null;\n            latlngs = latlngs || this._latlngs;\n            if (!latlngs.length) return shape;\n            else if (L.Polyline._flat(latlngs) && this.isInLatLngs(latlng, latlngs)) shape = latlngs;\n            else if (L.Polyline._flat(latlngs[0]) && this.isInLatLngs(latlng, latlngs[0])) shape = latlngs;\n            else for (var i = 0; i < latlngs.length; i++) if (this.isInLatLngs(latlng, latlngs[i][0])) return latlngs[i];\n            return shape;\n        },\n\n        isInLatLngs: function (l, latlngs) {\n            var inside = false, l1, l2, j, k, len2;\n\n            for (j = 0, len2 = latlngs.length, k = len2 - 1; j < len2; k = j++) {\n                l1 = latlngs[j];\n                l2 = latlngs[k];\n\n                if (((l1.lat > l.lat) !== (l2.lat > l.lat)) &&\n                        (l.lng < (l2.lng - l1.lng) * (l.lat - l1.lat) / (l2.lat - l1.lat) + l1.lng)) {\n                    inside = !inside;\n                }\n            }\n\n            return inside;\n        },\n\n        parentShape: function (shape, latlngs) {\n            latlngs = latlngs || this._latlngs;\n            if (!latlngs) return;\n            var idx = L.Util.indexOf(latlngs, shape);\n            if (idx !== -1) return latlngs;\n            for (var i = 0; i < latlngs.length; i++) {\n                idx = L.Util.indexOf(latlngs[i], shape);\n                if (idx !== -1) return latlngs[i];\n            }\n        }\n\n    };\n\n\n    var MarkerMixin = {\n\n        getEditorClass: function (tools) {\n            return (tools && tools.options.markerEditorClass) ? tools.options.markerEditorClass : L.Editable.MarkerEditor;\n        }\n\n    };\n\n    var RectangleMixin = {\n\n        getEditorClass: function (tools) {\n            return (tools && tools.options.rectangleEditorClass) ? tools.options.rectangleEditorClass : L.Editable.RectangleEditor;\n        }\n\n    };\n\n    var CircleMixin = {\n\n        getEditorClass: function (tools) {\n            return (tools && tools.options.circleEditorClass) ? tools.options.circleEditorClass : L.Editable.CircleEditor;\n        }\n\n    };\n\n    var keepEditable = function () {\n        // Make sure you can remove/readd an editable layer.\n        this.on('add', this._onEditableAdd);\n    };\n\n\n\n    if (L.Polyline) {\n        L.Polyline.include(EditableMixin);\n        L.Polyline.include(PolylineMixin);\n        L.Polyline.addInitHook(keepEditable);\n    }\n    if (L.Polygon) {\n        L.Polygon.include(EditableMixin);\n        L.Polygon.include(PolygonMixin);\n    }\n    if (L.Marker) {\n        L.Marker.include(EditableMixin);\n        L.Marker.include(MarkerMixin);\n        L.Marker.addInitHook(keepEditable);\n    }\n    if (L.Rectangle) {\n        L.Rectangle.include(EditableMixin);\n        L.Rectangle.include(RectangleMixin);\n    }\n    if (L.Circle) {\n        L.Circle.include(EditableMixin);\n        L.Circle.include(CircleMixin);\n    }\n\n    L.LatLng.prototype.update = function (latlng) {\n        latlng = L.latLng(latlng);\n        this.lat = latlng.lat;\n        this.lng = latlng.lng;\n    }\n\n}, window));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/leaflet-editable/src/Leaflet.Editable.js\n// module id = 2\n// module chunks = 0","'use strict';\n\n/* A Draggable that does not update the element position\nand takes care of only bubbling to targetted path in Canvas mode. */\nL.PathDraggable = L.Draggable.extend({\n\n  initialize: function (path) {\n    this._path = path;\n    this._canvas = (path._map.getRenderer(path) instanceof L.Canvas);\n    var element = this._canvas ? this._path._map.getRenderer(this._path)._container : this._path._path;\n    L.Draggable.prototype.initialize.call(this, element, element, true);\n  },\n\n  _updatePosition: function () {\n    var e = {originalEvent: this._lastEvent};\n    this.fire('drag', e);\n  },\n\n  _onDown: function (e) {\n    var first = e.touches ? e.touches[0] : e;\n    this._startPoint = new L.Point(first.clientX, first.clientY);\n    if (this._canvas && !this._path._containsPoint(this._path._map.mouseEventToLayerPoint(first))) { return; }\n    L.Draggable.prototype._onDown.call(this, e);\n  }\n\n});\n\n\nL.Handler.PathDrag = L.Handler.extend({\n\n  initialize: function (path) {\n    this._path = path;\n  },\n\n  getEvents: function () {\n    return {\n      dragstart: this._onDragStart,\n      drag: this._onDrag,\n      dragend: this._onDragEnd\n    };\n  },\n\n  addHooks: function () {\n    if (!this._draggable) { this._draggable = new L.PathDraggable(this._path); }\n    this._draggable.on(this.getEvents(), this).enable();\n    L.DomUtil.addClass(this._draggable._element, 'leaflet-path-draggable');\n  },\n\n  removeHooks: function () {\n    this._draggable.off(this.getEvents(), this).disable();\n    L.DomUtil.removeClass(this._draggable._element, 'leaflet-path-draggable');\n  },\n\n  moved: function () {\n    return this._draggable && this._draggable._moved;\n  },\n\n  _onDragStart: function () {\n    this._startPoint = this._draggable._startPoint;\n    this._path\n        .closePopup()\n        .fire('movestart')\n        .fire('dragstart');\n  },\n\n  _onDrag: function (e) {\n    var path = this._path,\n        event = (e.originalEvent.touches && e.originalEvent.touches.length === 1 ? e.originalEvent.touches[0] : e.originalEvent),\n        newPoint = L.point(event.clientX, event.clientY),\n        latlng = path._map.layerPointToLatLng(newPoint);\n\n    this._offset = newPoint.subtract(this._startPoint);\n    this._startPoint = newPoint;\n\n    this._path.eachLatLng(this.updateLatLng, this);\n    path.redraw();\n\n    e.latlng = latlng;\n    e.offset = this._offset;\n    path.fire('move', e)\n        .fire('drag', e);\n  },\n\n  _onDragEnd: function (e) {\n    if (this._path._bounds) this.resetBounds();\n    this._path.fire('moveend')\n        .fire('dragend', e);\n  },\n\n  latLngToLayerPoint: function (latlng) {\n    // Same as map.latLngToLayerPoint, but without the round().\n    var projectedPoint = this._path._map.project(L.latLng(latlng));\n    return projectedPoint._subtract(this._path._map.getPixelOrigin());\n  },\n\n  updateLatLng: function (latlng) {\n    var oldPoint = this.latLngToLayerPoint(latlng);\n    oldPoint._add(this._offset);\n    var newLatLng = this._path._map.layerPointToLatLng(oldPoint);\n    latlng.lat = newLatLng.lat;\n    latlng.lng = newLatLng.lng;\n  },\n\n  resetBounds: function () {\n    this._path._bounds = new L.LatLngBounds();\n    this._path.eachLatLng(function (latlng) {\n      this._bounds.extend(latlng);\n    });\n  }\n\n});\n\nL.Path.include({\n\n  eachLatLng: function (callback, context) {\n    context = context || this;\n    var loop = function (latlngs) {\n      for (var i = 0; i < latlngs.length; i++) {\n        if (L.Util.isArray(latlngs[i])) loop(latlngs[i]);\n        else callback.call(context, latlngs[i]);\n      }\n    };\n    loop(this.getLatLngs ? this.getLatLngs() : [this.getLatLng()]);\n  }\n\n});\n\nL.Path.addInitHook(function () {\n\n  this.dragging = new L.Handler.PathDrag(this);\n  if (this.options.draggable) {\n    this.once('add', function () {\n      this.dragging.enable();\n    });\n  }\n\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/leaflet.path.drag/src/Path.Drag.js\n// module id = 3\n// module chunks = 0"],"sourceRoot":""}